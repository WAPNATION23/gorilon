<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ZombiGotchi: Protocolo Goril√≥n v2.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 800px;
            max-height: 600px;
            background-color: #9bbc0f;
            border: 8px solid #0f380f;
            border-radius: 12px;
            box-shadow: 0 0 40px rgba(155, 188, 15, 0.3);
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        #ui {
            position: absolute;
            top: 8px;
            left: 12px;
            right: 12px;
            color: #0f380f;
            font-weight: bold;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 10;
        }

        #weaponUI {
            position: absolute;
            top: 30px;
            left: 12px;
            color: #0f380f;
            font-size: 12px;
            z-index: 10;
        }

        #goriStatus.active {
            animation: pulse 0.3s infinite alternate;
        }

        #goriStatus.satanic {
            color: #ff0000 !important;
            text-shadow: 0 0 10px #ff0000;
        }

        @keyframes pulse {
            from {
                opacity: 0.7;
            }

            to {
                opacity: 1;
            }
        }

        #joystickContainer {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 100px;
            height: 100px;
            z-index: 100;
        }

        #joystickBase {
            width: 100px;
            height: 100px;
            background: radial-gradient(circle at 30% 30%, #4a4a4a 0%, #1a1a1a 100%);
            border: 3px solid #0f380f;
            border-radius: 50%;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.5);
        }

        #joystickStick {
            position: absolute;
            width: 45px;
            height: 45px;
            background: radial-gradient(circle at 35% 35%, #666 0%, #1a1a1a 100%);
            border: 2px solid #0f380f;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #fireButton {
            position: absolute;
            bottom: 25px;
            right: 25px;
            width: 80px;
            height: 80px;
            background: radial-gradient(circle at 35% 35%, #8bac0f 0%, #0f380f 100%);
            border: 4px solid #0f380f;
            border-radius: 50%;
            box-shadow: 0 6px 0 #0a2a0a;
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
        }

        #fireButton:active {
            transform: translateY(6px);
            box-shadow: 0 2px 0 #0a2a0a;
        }

        #weaponSwitch {
            position: absolute;
            bottom: 115px;
            right: 30px;
            width: 70px;
            height: 35px;
            background: #306230;
            border: 2px solid #0f380f;
            border-radius: 6px;
            color: #9bbc0f;
            font-weight: bold;
            font-size: 10px;
            z-index: 100;
        }

        #levelIntro,
        #gameOverScreen,
        #victoryScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            text-align: center;
            padding: 20px;
        }

        #levelIntro {
            background: rgba(15, 56, 15, 0.97);
        }

        #gameOverScreen {
            background: rgba(15, 56, 15, 0.95);
        }

        #victoryScreen {
            background: linear-gradient(135deg, #ff6b9d 0%, #ff3366 100%);
            overflow: hidden;
        }

        #levelIntro h2,
        #gameOverScreen h1 {
            color: #9bbc0f;
            font-size: 26px;
            margin-bottom: 15px;
        }

        #poemText {
            color: #8bac0f;
            font-size: 14px;
            line-height: 1.6;
            max-width: 380px;
            margin-bottom: 20px;
            font-style: italic;
        }

        .gameBtn {
            padding: 14px 35px;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            background: #9bbc0f;
            color: #0f380f;
            border: 4px solid #306230;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 5px 0 #306230;
        }

        .gameBtn:active {
            transform: translateY(3px);
            box-shadow: 0 2px 0 #306230;
        }

        #gorillaSpeech {
            position: absolute;
            background: #fff;
            color: #0f380f;
            padding: 6px 10px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: bold;
            max-width: 160px;
            text-align: center;
            display: none;
            z-index: 50;
            pointer-events: none;
        }

        #victoryScreen h1 {
            font-size: 36px;
            color: #fff;
            margin-bottom: 15px;
        }

        #victoryScreen p {
            color: #fff;
            font-size: 18px;
            margin-bottom: 20px;
        }

        .love-explosion {
            position: absolute;
            font-size: 24px;
            animation: floatUp 3s ease-out forwards;
            pointer-events: none;
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }

            100% {
                opacity: 0;
                transform: translateY(-350px) scale(1.3);
            }
        }

        .te-quiero {
            position: absolute;
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            text-shadow: 2px 2px 0 #ff1a75;
            animation: teQuieroFloat 3s ease-out forwards;
            pointer-events: none;
        }

        @keyframes teQuieroFloat {
            0% {
                opacity: 1;
                transform: scale(0.5);
            }

            50% {
                opacity: 1;
                transform: scale(1.1);
            }

            100% {
                opacity: 0;
                transform: translateY(-250px) scale(0.7);
            }
        }

        #bossHealth {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 16px;
            background: #0f380f;
            border: 2px solid #fff;
            border-radius: 4px;
            display: none;
            z-index: 20;
        }

        #bossHealthBar {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6600);
            border-radius: 2px;
            transition: width 0.2s;
        }

        #bossLabel {
            position: absolute;
            top: 34px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff0000;
            font-weight: bold;
            font-size: 12px;
            display: none;
            z-index: 20;
            text-shadow: 1px 1px 0 #000;
        }

        /* Music Button */
        #musicBtn {
            position: absolute;
            top: 8px;
            right: 60px;
            width: 40px;
            height: 40px;
            background: #306230;
            border: 3px solid #0f380f;
            border-radius: 8px;
            font-size: 20px;
            z-index: 100;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #musicBtn.muted {
            opacity: 0.5;
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <div id="ui">
            <span>SCORE: <span id="scoreDisplay">0</span></span>
            <span id="roomIndicator">1/7</span>
            <span>ü¶ç <span id="goriStatus">OFF</span></span>
        </div>
        <div id="weaponUI">üî´ <span id="weaponName">PISTOLA</span></div>
        <button id="musicBtn" title="Toggle Music">üîä</button>
        <div id="bossLabel">‚ò†Ô∏è ZOMBIE BOSS ‚ò†Ô∏è</div>
        <div id="bossHealth">
            <div id="bossHealthBar" style="width:100%"></div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="gorillaSpeech"></div>
        <div id="joystickContainer">
            <div id="joystickBase">
                <div id="joystickStick"></div>
            </div>
        </div>
        <button id="weaponSwitch">ARMA ‚û°Ô∏è</button>
        <div id="fireButton">üî•</div>
        <div id="levelIntro">
            <h2 id="levelTitle">üè† HABITACI√ìN 1</h2>
            <p id="poemText"></p><button class="gameBtn" id="startLevelBtn">‚ñ∂ COMENZAR</button>
        </div>
        <div id="gameOverScreen">
            <h1>‚ò†Ô∏è GAME OVER ‚ò†Ô∏è</h1>
            <p id="gameOverMessage"></p><button class="gameBtn" id="restartButton">üîÑ REINTENTAR</button>
            <p id="finalScore"></p>
        </div>
        <div id="victoryScreen">
            <div id="victoryContent">
                <h1>üèÜ ¬°GANASTE! üèÜ</h1>
                <p>¬°Completaste las 7 habitaciones!</p>
                <p id="victoryScore"></p><button class="gameBtn" id="playAgainBtn">üíï JUGAR DE NUEVO</button>
            </div>
        </div>
    </div>


    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('gameContainer');
        const MAX_ROOMS = 7;

        // === FIX CANVAS RESOLUTION ===
        function resizeCanvas() {
            const rect = container.getBoundingClientRect();
            // Zoom out: render at higher resolution for wider FOV
            const zoomOut = 1.45;
            canvas.width = rect.width * zoomOut;
            canvas.height = rect.height * zoomOut;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // UI Elements
        const $ = id => document.getElementById(id);

        // === MUSIC SYSTEM (YouTube IFrame API - Most Reliable) ===
        const musicBtn = $('musicBtn');
        let musicPlaying = false;
        let ytPlayer = null;
        let ytReady = false;

        // Load YouTube IFrame API
        const ytScript = document.createElement('script');
        ytScript.src = 'https://www.youtube.com/iframe_api';
        document.head.appendChild(ytScript);

        // YouTube API calls this automatically when ready
        window.onYouTubeIframeAPIReady = function () {
            // Create hidden container for YT player
            const ytDiv = document.createElement('div');
            ytDiv.id = 'ytplayer';
            ytDiv.style.cssText = 'position:absolute;width:1px;height:1px;overflow:hidden;opacity:0;pointer-events:none;';
            document.body.appendChild(ytDiv);

            ytPlayer = new YT.Player('ytplayer', {
                height: '1',
                width: '1',
                videoId: 'cE6wxDqdOV0', // Lana Del Rey - Video Games
                playerVars: {
                    autoplay: 0,
                    loop: 1,
                    playlist: 'cE6wxDqdOV0', // needed for loop
                    controls: 0,
                    disablekb: 1,
                    fs: 0,
                    modestbranding: 1,
                    rel: 0
                },
                events: {
                    onReady: function () {
                        ytReady = true;
                        ytPlayer.setVolume(50);
                        console.log('üéµ YouTube player ready');
                    },
                    onStateChange: function (e) {
                        // If video ends, replay (backup for loop)
                        if (e.data === YT.PlayerState.ENDED) {
                            ytPlayer.playVideo();
                        }
                    }
                }
            });
        };

        function tryPlayMusic() {
            if (ytReady && ytPlayer && !musicPlaying) {
                ytPlayer.playVideo();
                musicPlaying = true;
                musicBtn.textContent = 'üéµ';
                musicBtn.classList.remove('muted');
            }
        }

        function toggleMusic() {
            if (!ytReady || !ytPlayer) return;
            if (musicPlaying) {
                ytPlayer.pauseVideo();
                musicBtn.textContent = 'üîá';
                musicBtn.classList.add('muted');
            } else {
                ytPlayer.playVideo();
                musicBtn.textContent = 'üéµ';
                musicBtn.classList.remove('muted');
            }
            musicPlaying = !musicPlaying;
        }

        musicBtn.onclick = toggleMusic;
        musicBtn.ontouchend = (e) => { e.preventDefault(); toggleMusic(); };
        const scoreDisplay = $('scoreDisplay');
        const goriStatusEl = $('goriStatus');
        const roomIndicator = $('roomIndicator');
        const weaponName = $('weaponName');
        const gameOverScreen = $('gameOverScreen');
        const gameOverMessage = $('gameOverMessage');
        const finalScore = $('finalScore');
        const levelIntro = $('levelIntro');
        const levelTitle = $('levelTitle');
        const poemText = $('poemText');
        const victoryScreen = $('victoryScreen');
        const victoryScore = $('victoryScore');
        const joystickStick = $('joystickStick');
        const gorillaSpeech = $('gorillaSpeech');
        const bossHealthEl = $('bossHealth');
        const bossHealthBar = $('bossHealthBar');
        const bossLabel = $('bossLabel');

        // Colors
        const C = { DARK: '#0f380f', MID: '#306230', LIGHT: '#8bac0f', BG: '#1a1a1a', FLOOR: '#252525', PINK: '#ffb6c1', HOTPINK: '#ff69b4 ' };

        // Weapons
        const WEAPONS = [
            { name: 'PISTOLA', emoji: 'üî´', fireRate: 150, spread: 0, pellets: 1, damage: 1, color: C.DARK },
            { name: 'ESCOPETA', emoji: 'üí•', fireRate: 400, spread: 0.35, pellets: 7, damage: 1, color: '#8b4513' },
            { name: 'MINIGUN', emoji: 'üî•', fireRate: 60, spread: 0.12, pellets: 1, damage: 1, color: '#ff4500' },
            { name: 'LANZALLAMAS', emoji: 'üî•', fireRate: 40, spread: 0.45, pellets: 4, damage: 0.5, color: '#ff6600', isFlame: true }
        ];

        // Poems
        const POEMS = [
            "üéÄ Hello Kitty entra al campo de batalla,\nCon su lazo rosa y valor sin igual.\n¬°Los zombis tiemblan ante tanta maravilla!",
            "üåô Segunda morada, el peligro crece,\nPero Hello Kitty nunca retrocede.\n¬°Adelante, guerrera de rosa y blanco!",
            "‚öîÔ∏è Tres victorias, tres lazos de honor,\nEl Goril√≥n ruge con fervor.\n¬°Nadie detiene a esta dupla ganadora!",
            "üî• Cuatro batallas, el fuego arde,\nHello Kitty no conoce lo cobarde.\n¬°Los zombis huyen de su mirada!",
            "ü¶ç El Goril√≥n susurra con amor:\n\"¬°Esta gatita es mi se√±ora!\"\n¬°Juntos son invencibles!",
            "üí´ Casi llegas al final glorioso,\nEl camino ha sido victorioso.\n¬°Una habitaci√≥n m√°s, campeona!",
            "üëë LA BATALLA FINAL TE ESPERA\nEl Boss Zombi quiere pelea,\nPero Hello Kitty es la verdadera\n¬°REINA DEL APOCALIPSIS!"
        ];

        const GORILLA_PHRASES = ["SALE PAJAR√ìN CULIAO FEO ü¶ç", "PERRO IJO LA PERRA üêï", "SAPO CTMRE üê∏", "ROBO M√ÅS QUE USTEDES WEON", "YOJOI CHORO WUOM üò§", "√âNFASISSS üí™üî•", "CON MI SE√ëORA NO PAJAR√ìN CULIAO ü¶ç‚ù§Ô∏è", "AL√âJATE DE MI KUROMI CULIAO üíÄ", "CARTERA DE MIMBRE Y LA CTMRE KSAKJSKJ üß∫", "ANDA PA LA CASA PERKIN QL üè†", "TERRIBLE DE SACOWEA ESTE ZOMBI üíÄ", "SOY M√ÅS CHORO QUE TODOS USTEDES üòé", "PURO PERKIN MUERTO AQU√ç WUOM ü™¶", "CACH√ÅI O NO CACH√ÅI CTMRE üß†"];
        const GAME_OVER_MSG = ["CAGASTE WUOM üíÄ", "El Goril√≥n se fue pal hoyo ü¶çüíî", "Los zombis te sacaron la chucha üéâ", "¬°Vuelve m√°s choro! üí™", "TERRIBLE DE MALO WUON üò≠"];

        // üî• COMBO KILL MESSAGES - Chilean combo phrases
        const COMBO_MSGS = [
            { min: 3, text: "TRIPLE KILL WUOM üî•", color: "#ffaa00" },
            { min: 5, text: "ANDAI ON FIRE SE√ëORA üî•üî•", color: "#ff6600" },
            { min: 8, text: "TERRIBLE DE CHORA MI SE√ëORA üí™‚ú®", color: "#ff00ff" },
            { min: 12, text: "DIOSA DEL APOCALIPSIS üëëüî•", color: "#ff0088" },
            { min: 16, text: "NADIE TE PARA KUROMI HERMOSA üíúü¶ç", color: "#aa00ff" },
            { min: 20, text: "ERES LA M√ÅS CHORA DEL MUNDO üåé‚ù§Ô∏è‚Äçüî•", color: "#ff1493" }
        ];

        // üíÄ ZOMBIE DEATH CRIES - Funny Chilean zombie last words
        const ZOMBIE_DEATHS = [
            "AAAH LA WE√ÅAA üíÄ", "ME MOR√ç COMO PERKIN ü™¶", "NOOOO CTMRE üò±",
            "ME DOLI√ì EL ALMA WN üëª", "DILE A MI VIEJA Q LA QUIERO üò≠",
            "ERA PERK√çN NOM√ÅI üòµ", "CAG√ì LA COSA üí©", "ME SAC√ì LA CHUCHA ü§ï",
            "YA FUE... WN ü´†", "MAMI AUXILIO üßü", "NO ERA TAN CHORO üòÖ",
            "ME HICIERON PEBRE ü•ò", "ANDABA VOLAO NOMAS üçÉ", "GG WN üéÆ"
        ];

        // ü¶ç‚ù§Ô∏è GORILLA PIROPOS - Love phrases mixed with Chilean humor
        const GORILLA_PIROPOS = [
            "MI SE√ëORA ES LA M√ÅS BELLA DEL APOCALIPSIS ü¶ç‚ù§Ô∏è",
            "POR TI ME HAGO VEGANO WUOM ü•¨ü¶ç",
            "TE QUIERO M√ÅS QUE A LOS PL√ÅTANOS üçå‚ù§Ô∏è",
            "SOMOS EL D√öO M√ÅS CHORO DEL MUNDO üí™‚ù§Ô∏è",
            "MI KUROMI HERMOSA, POR TI DOY LA VIDA ü¶çüíú",
            "ERES M√ÅS LINDA QUE UNA EMPANADA EN SEPTIEMBRE ü•ü‚ù§Ô∏è",
            "CONTIGO HASTA EN EL APOCALIPSIS SOY FELIZ üßü‚ù§Ô∏è",
            "MI CORAZ√ìN ES TUYO SE√ëORA WUOM üíòü¶ç",
            "JUNTOS SOMOS INVENCIBLES MI AMOR üíïüî•",
            "ELLA ME HACE M√ÅS CHORO üëâ‚ù§Ô∏èüëà"
        ];

        // üíÄ MINI-BOSS NAMES & PHRASES
        const MINIBOSS_NAMES = [
            "ZOMBI CHORO üíÄ", "EL PERKIN GRANDE üßü", "ZOMBI FLAITE üî•",
            "EL SACOWEA MAYOR üí™", "ZOMBI MAT√ìN üëπ", "PERKIN ALPHA ü¶¥"
        ];
        const MINIBOSS_GORILLA_TAUNT = [
            "VENGA PA AC√Å PERKIN GRANDE ü¶çüí™", "ESTE CULIAO ES M√çO WUOM ü¶çüî•",
            "TE VOY A SACAR LA CHUCHA PERKIN üëä", "ATR√ÅS MI SE√ëORA, ESTE ES M√çO ü¶ç‚ù§Ô∏è",
            "JAJAJA ESTE WEON SE CREE CHORO ü¶çüò§", "VOY A HACERTE PEBRE CTMRE ü¶çü©∏"
        ];

        // üéÆ KONAMI CODE sequence
        const KONAMI_CODE = ['ArrowUp','ArrowUp','ArrowDown','ArrowDown','ArrowLeft','ArrowRight','ArrowLeft','ArrowRight','b','a'];
        let konamiIndex = 0;
        let miniBosses = [];

        // World size (expandable map)
        const WORLD = { w: 1200, h: 900 };

        // State
        let gs = {};
        let player = {};
        let camera = { x: 0, y: 0 };
        let bullets = [];
        let zombies = [];
        let items = [];
        let obstacles = [];
        let gorilla = {};
        let boss = null;
        let joystick = { active: false, baseX: 0, baseY: 0, maxDist: 40 };
        let loveInterval = null;
        let checkpoint = 1; // Guardar el nivel actual como checkpoint

        function init() {
            if (loveInterval) clearInterval(loveInterval);
            document.querySelectorAll('.love-explosion,.te-quiero').forEach(e => e.remove());

            gs = { score: 0, room: checkpoint, kills: 0, toKill: 20 + checkpoint * 3, over: false, won: false, paused: true, goriActive: true, goriTimer: 0, goriSpeechTimer: 0, pulse: 0, floats: [], weapon: 0, satanic: false, satTimer: 0, combo: 0, comboTimer: 0, maxCombo: 0, piropoTimer: 0 };
            player = { x: WORLD.w / 2 - 16, y: WORLD.h / 2 - 16, w: 32, h: 32, speed: 2.5, dx: 0, dy: 0, frame: 0, aim: 0 };
            gorilla = { x: WORLD.w / 2 + 30, y: WORLD.h / 2 - 16, w: 56, h: 56, speed: 2, target: null, punch: 0, walk: 0, attackCooldown: 0 };
            boss = null;
            bullets = []; zombies = []; items = []; particles = []; miniBosses = [];
            genObstacles();
            updateUI();
            gameOverScreen.style.display = 'none';
            victoryScreen.style.display = 'none';
            bossHealthEl.style.display = 'none';
            bossLabel.style.display = 'none';
            showIntro();
        }

        function showIntro() {
            gs.paused = true;
            levelTitle.innerText = `üè† HABITACI√ìN ${gs.room}/${MAX_ROOMS}`;
            poemText.innerText = POEMS[gs.room - 1];
            levelIntro.style.display = 'flex';
        }

        function startLevel() {
            levelIntro.style.display = 'none';
            gs.paused = false;

            // FORCE MUSIC START DIRECTLY
            tryPlayMusic();

            // Gorilla greeting at start of each level
            const greetings = [
                "VAMOS MI SE√ëORA, YO TE CUIDO ü¶ç‚ù§Ô∏è", "LISTA PA ROMPERLA WUOM ü¶çüí™",
                "JUNTOS SOMOS IMPARABLES ü¶çüéÄ", "EL GORIL√ìN LLEG√ì PA QUEDARSE ü¶çüî•",
                "PA DELANTE MI KUROMI HERMOSA ü¶çüíú", "LOS PERKIN NO SABEN LO QUE LES ESPERA ü¶çüò§"
            ];
            setTimeout(() => showSpeech(greetings[Math.floor(Math.random() * greetings.length)]), 500);

            // Spawn boss on room 4 and 7
            if (gs.room === 4 || gs.room === 7) {
                spawnBoss();
            }
        }

        function spawnBoss() {
            boss = {
                x: WORLD.w / 2 - 40,
                y: 100,
                w: 80, h: 80,
                hp: 150 + gs.room * 30,
                maxHp: 150 + gs.room * 30,
                speed: 1.2,
                frame: 0,
                hit: 0
            };
            bossHealthEl.style.display = 'block';
            bossLabel.style.display = 'block';
        }

        $('startLevelBtn').onclick = startLevel;
        $('startLevelBtn').ontouchend = e => { e.preventDefault(); startLevel(); };

        function showVictory() {
            gs.won = true;
            gs.paused = true;
            victoryScore.innerText = `Puntuaci√≥n: ${gs.score} üåü`;
            victoryScreen.style.display = 'flex';
            startLoveExplosion();
        }

        function startLoveExplosion() {
            const hearts = ['‚ù§Ô∏è', 'üíï', 'üíñ', 'üíó', 'ü¶ç', '‚ú®', 'üéÄ', 'üåü'];
            const texts = ['TE QUIERO', 'TE AMO', 'CONY ‚ù§Ô∏è', 'ERES LA MEJOR', 'GANASTE', 'ü¶çüíï', 'CAMPEONA', 'HELLO KITTY'];
            let count = 0;

            function create() {
                if (count++ > 80) { clearInterval(loveInterval); return; }
                const h = document.createElement('div');
                h.className = 'love-explosion';
                h.innerText = hearts[Math.floor(Math.random() * hearts.length)];
                h.style.left = Math.random() * 100 + '%';
                h.style.top = (75 + Math.random() * 25) + '%';
                h.style.fontSize = (18 + Math.random() * 25) + 'px';
                victoryScreen.appendChild(h);
                setTimeout(() => h.remove(), 3500);

                if (Math.random() > 0.4) {
                    const t = document.createElement('div');
                    t.className = 'te-quiero';
                    t.innerText = texts[Math.floor(Math.random() * texts.length)];
                    t.style.left = (10 + Math.random() * 80) + '%';
                    t.style.top = (70 + Math.random() * 30) + '%';
                    victoryScreen.appendChild(t);
                    setTimeout(() => t.remove(), 3500);
                }
            }
            for (let i = 0; i < 15; i++) setTimeout(create, i * 40);
            loveInterval = setInterval(create, 90);
        }

        $('playAgainBtn').onclick = init;
        $('restartButton').onclick = init;

        function genObstacles() {
            obstacles = [];
            const n = 6 + gs.room;
            const types = ['ruin', 'tree', 'tomb', 'car', 'blood', 'barrel'];

            for (let i = 0; i < n; i++) {
                let x, y, ok = false, att = 0;
                while (!ok && att++ < 40) {
                    x = 80 + Math.random() * (WORLD.w - 200);
                    y = 80 + Math.random() * (WORLD.h - 200);
                    const d = Math.hypot(x - WORLD.w / 2, y - WORLD.h / 2);
                    if (d > 120) ok = true;
                }
                if (ok) {
                    const type = types[Math.floor(Math.random() * types.length)];
                    let w = 50, h = 50;
                    if (type === 'ruin') { w = 60 + Math.random() * 50; h = 50 + Math.random() * 40; }
                    else if (type === 'tree') { w = 30; h = 60; }
                    else if (type === 'tomb') { w = 35; h = 45; }
                    else if (type === 'car') { w = 70; h = 35; }
                    else if (type === 'blood') { w = 40; h = 40; }
                    else if (type === 'barrel') { w = 25; h = 30; }
                    // Blood pools and trees don't block movement
                    const noBlock = (type === 'blood');
                    obstacles.push({ x, y, w, h, type, noCollide: noBlock });
                }
            }
            // Add some decorative blood pools (non-blocking)
            for (let i = 0; i < 8; i++) {
                const x = 50 + Math.random() * (WORLD.w - 100);
                const y = 50 + Math.random() * (WORLD.h - 100);
                obstacles.push({ x, y, w: 30, h: 20, type: 'decor_blood', noCollide: true });
            }
        }

        function updateUI() {
            scoreDisplay.innerText = gs.score;
            roomIndicator.innerText = `${gs.room}/${MAX_ROOMS}`;
            const w = WEAPONS[gs.weapon];
            weaponName.innerText = `${w.emoji} ${w.name}`;
            goriStatusEl.innerText = gs.satanic ? '¬°SAT√ÅNICO! üëπüî•' : 'ü¶ç COMPA√ëERO';
            goriStatusEl.classList.toggle('active', true);
            goriStatusEl.classList.toggle('satanic', gs.satanic);
        }

        // Switch weapon
        $('weaponSwitch').onclick = () => { gs.weapon = (gs.weapon + 1) % WEAPONS.length; updateUI(); };
        $('weaponSwitch').ontouchend = e => { e.preventDefault(); gs.weapon = (gs.weapon + 1) % WEAPONS.length; updateUI(); };

        // === PARTICLE SYSTEM ===
        let particles = [];
        function addParticles(x, y, color, count, speed, life) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const spd = (0.5 + Math.random()) * speed;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * spd,
                    vy: Math.sin(angle) * spd,
                    life: life || 30,
                    maxLife: life || 30,
                    color,
                    size: 2 + Math.random() * 3
                });
            }
        }
        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.96;
                p.vy *= 0.96;
                p.life--;
                if (p.life <= 0) return false;
                const sx = p.x - camera.x, sy = p.y - camera.y;
                const alpha = p.life / p.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(sx, sy, p.size * alpha, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                return true;
            });
        }

        // === DRAW HELLO KITTY (IMPROVED) ===
        function drawHelloKitty(sx, sy, frame, angle) {
            const x = sx - camera.x, y = sy - camera.y;
            ctx.save();
            ctx.translate(x + 16, y + 16);

            // Soft glow under character
            ctx.shadowColor = '#ff69b4';
            ctx.shadowBlur = 12;
            ctx.fillStyle = 'rgba(255, 105, 180, 0.15)';
            ctx.beginPath();
            ctx.ellipse(0, 20, 18, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            ctx.rotate(angle);

            // Legs (animated walk)
            const legAnim = Math.sin(frame * 0.2) * 3;
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(-4, 24 + legAnim, 4, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(4, 24 - legAnim, 4, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 0.5;
            ctx.stroke();

            // Body (pink dress)
            ctx.fillStyle = '#ffb6c1';
            ctx.beginPath();
            ctx.moveTo(-10, 12);
            ctx.quadraticCurveTo(-12, 22, -8, 24);
            ctx.lineTo(8, 24);
            ctx.quadraticCurveTo(12, 22, 10, 12);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#e0909e';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Body stripe
            ctx.fillStyle = '#ff99aa';
            ctx.fillRect(-2, 14, 4, 8);

            // Arms
            const armAnim = Math.sin(frame * 0.15) * 2;
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(-13, 14 + armAnim, 4, 6, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(13, 14 - armAnim, 4, 6, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Face (white circle with soft edge)
            const faceGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 14);
            faceGrad.addColorStop(0, '#ffffff');
            faceGrad.addColorStop(1, '#f0f0f0');
            ctx.fillStyle = faceGrad;
            ctx.beginPath();
            ctx.ellipse(0, 0, 14, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Ears
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#ccc';
            ctx.beginPath();
            ctx.moveTo(-10, -8);
            ctx.lineTo(-14, -18);
            ctx.lineTo(-4, -12);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Inner ear pink
            ctx.fillStyle = '#ffccdd';
            ctx.beginPath();
            ctx.moveTo(-9, -9);
            ctx.lineTo(-12, -16);
            ctx.lineTo(-5, -12);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(10, -8);
            ctx.lineTo(14, -18);
            ctx.lineTo(4, -12);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#ccc';
            ctx.stroke();
            ctx.fillStyle = '#ffccdd';
            ctx.beginPath();
            ctx.moveTo(9, -9);
            ctx.lineTo(12, -16);
            ctx.lineTo(5, -12);
            ctx.closePath();
            ctx.fill();

            // Bow (pink - bigger, nicer)
            ctx.fillStyle = '#ff69b4';
            ctx.beginPath();
            ctx.ellipse(-13, -14, 7, 5, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(-5, -16, 6, 4, 0.3, 0, Math.PI * 2);
            ctx.fill();
            // Bow highlight
            ctx.fillStyle = '#ff8dc7';
            ctx.beginPath();
            ctx.ellipse(-13, -15, 3, 2, -0.3, 0, Math.PI * 2);
            ctx.fill();
            // Bow center
            ctx.fillStyle = '#ff1493';
            ctx.beginPath();
            ctx.arc(-9, -15, 2.5, 0, Math.PI * 2);
            ctx.fill();

            // Eyes (with shine)
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(-5, -2, 2.2, 3.2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(5, -2, 2.2, 3.2, 0, 0, Math.PI * 2);
            ctx.fill();
            // Eye shine
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-4, -3, 1, 0, Math.PI * 2);
            ctx.arc(6, -3, 1, 0, Math.PI * 2);
            ctx.fill();

            // Nose
            ctx.fillStyle = '#ffcc00';
            ctx.beginPath();
            ctx.ellipse(0, 3, 2.5, 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffdd44';
            ctx.beginPath();
            ctx.ellipse(-0.5, 2.5, 1, 1, 0, 0, Math.PI * 2);
            ctx.fill();

            // Whiskers (smoother)
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 0.8;
            ctx.beginPath();
            ctx.moveTo(-16, -1); ctx.lineTo(-6, 1);
            ctx.moveTo(-16, 3); ctx.lineTo(-6, 3);
            ctx.moveTo(-16, 7); ctx.lineTo(-6, 5);
            ctx.moveTo(16, -1); ctx.lineTo(6, 1);
            ctx.moveTo(16, 3); ctx.lineTo(6, 3);
            ctx.moveTo(16, 7); ctx.lineTo(6, 5);
            ctx.stroke();

            // Weapon in hand
            ctx.fillStyle = WEAPONS[gs.weapon].color;
            ctx.save();
            ctx.translate(14, 12);
            ctx.rotate(0.3);
            ctx.fillRect(0, -2, 10, 4);
            ctx.fillStyle = '#333';
            ctx.fillRect(8, -3, 4, 6);
            ctx.restore();

            ctx.restore();
        }

        // === DRAW GORILLA (Satanic mode - IMPROVED) ===
        function drawGorilla(sx, sy, punch, walk) {
            const x = sx - camera.x, y = sy - camera.y;
            const p = punch > 0;
            const shake = p ? Math.sin(punch * 3) * 5 : 0;
            const bounce = Math.sin(walk * 0.15) * 2;

            ctx.save();
            ctx.translate(x + 28, y + 28);

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.35)';
            ctx.beginPath();
            ctx.ellipse(0, 38, 28, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.fillStyle = gs.satanic ? '#150000' : '#221508';
            ctx.beginPath();
            ctx.ellipse(-10 + shake, 30 + bounce, 8, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(10 + shake, 30 + bounce, 8, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Body with gradient
            const bodyGrad = ctx.createRadialGradient(shake, 8 + bounce, 5, shake, 10 + bounce, 26);
            bodyGrad.addColorStop(0, gs.satanic ? '#2a0505' : '#3a2a14');
            bodyGrad.addColorStop(1, gs.satanic ? '#0a0000' : '#1a0e04');
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.ellipse(shake, 10 + bounce, 24, 22, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = gs.satanic ? '#0a0000' : '#120a02';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Chest patch
            ctx.fillStyle = gs.satanic ? '#3a1010' : '#4a3a2a';
            ctx.beginPath();
            ctx.ellipse(shake, 6 + bounce, 12, 14, 0, 0, Math.PI * 2);
            ctx.fill();

            // Fur texture
            ctx.strokeStyle = gs.satanic ? '#200505' : '#2a1a0a';
            ctx.lineWidth = 0.8;
            for (let i = 0; i < 8; i++) {
                const fx = shake + (Math.random() - 0.5) * 40;
                const fy = bounce + (Math.random() - 0.5) * 35;
                ctx.beginPath();
                ctx.moveTo(fx, fy);
                ctx.lineTo(fx + (Math.random() - 0.5) * 6, fy + 4);
                ctx.stroke();
            }

            // Head with gradient
            const headGrad = ctx.createRadialGradient(shake, -16 + bounce, 3, shake, -14 + bounce, 18);
            headGrad.addColorStop(0, gs.satanic ? '#2a0505' : '#3a2a14');
            headGrad.addColorStop(1, gs.satanic ? '#0a0000' : '#1a0e04');
            ctx.fillStyle = headGrad;
            ctx.beginPath();
            ctx.ellipse(shake, -14 + bounce, 16, 14, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = gs.satanic ? '#0a0000' : '#120a02';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Brow ridge
            ctx.fillStyle = gs.satanic ? '#1a0000' : '#2a1a0a';
            ctx.beginPath();
            ctx.ellipse(shake, -20 + bounce, 14, 4, 0, 0, Math.PI);
            ctx.fill();

            // Face
            ctx.fillStyle = gs.satanic ? '#4a2020' : '#7a6a5a';
            ctx.beginPath();
            ctx.ellipse(shake, -10 + bounce, 10, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nostrils
            ctx.fillStyle = gs.satanic ? '#2a0a0a' : '#3a2a1a';
            ctx.beginPath();
            ctx.ellipse(-3 + shake, -7 + bounce, 2, 1.5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(3 + shake, -7 + bounce, 2, 1.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // SATANIC EYES
            if (gs.satanic) {
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 20;
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(-6 + shake, -15 + bounce, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(6 + shake, -15 + bounce, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                // Slit pupils
                ctx.fillStyle = '#440000';
                ctx.fillRect(-6.5 + shake, -18 + bounce, 1, 6);
                ctx.fillRect(5.5 + shake, -18 + bounce, 1, 6);

                // Horns (curved)
                const hornGrad = ctx.createLinearGradient(0, -22 + bounce, 0, -40 + bounce);
                hornGrad.addColorStop(0, '#660000');
                hornGrad.addColorStop(1, '#ff2200');
                ctx.fillStyle = hornGrad;
                ctx.beginPath();
                ctx.moveTo(-14 + shake, -22 + bounce);
                ctx.quadraticCurveTo(-12 + shake, -32 + bounce, -6 + shake, -38 + bounce);
                ctx.quadraticCurveTo(-8 + shake, -30 + bounce, -4 + shake, -22 + bounce);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(14 + shake, -22 + bounce);
                ctx.quadraticCurveTo(12 + shake, -32 + bounce, 6 + shake, -38 + bounce);
                ctx.quadraticCurveTo(8 + shake, -30 + bounce, 4 + shake, -22 + bounce);
                ctx.fill();
            } else {
                ctx.fillStyle = p ? '#ff3333' : '#fff';
                ctx.beginPath();
                ctx.arc(-6 + shake, -15 + bounce, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(6 + shake, -15 + bounce, 3, 0, Math.PI * 2);
                ctx.fill();
                // Pupils
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-6 + shake, -15 + bounce, 1.5, 0, Math.PI * 2);
                ctx.arc(6 + shake, -15 + bounce, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Mouth when punching
            if (p) {
                ctx.fillStyle = gs.satanic ? '#aa0000' : '#330000';
                ctx.beginPath();
                ctx.ellipse(shake, -3 + bounce, 7, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(-5 + shake, -5 + bounce);
                ctx.lineTo(-3 + shake, -2 + bounce);
                ctx.lineTo(-1 + shake, -5 + bounce);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(1 + shake, -5 + bounce);
                ctx.lineTo(3 + shake, -2 + bounce);
                ctx.lineTo(5 + shake, -5 + bounce);
                ctx.fill();
            }

            // Arms (muscular with fists)
            const armExt = p ? 20 : 0;
            const armY = p ? -8 : 6;
            ctx.fillStyle = gs.satanic ? '#1a0000' : '#2a1a0a';
            ctx.beginPath();
            ctx.ellipse(-26 - armExt + shake, armY + bounce, 12, 9, -0.2, 0, Math.PI * 2);
            ctx.fill();
            const fistGrad = ctx.createRadialGradient(-36 - armExt + shake, armY + bounce, 1, -36 - armExt + shake, armY + bounce, 8);
            fistGrad.addColorStop(0, gs.satanic ? '#2a0505' : '#3a2a14');
            fistGrad.addColorStop(1, gs.satanic ? '#0a0000' : '#1a0e04');
            ctx.fillStyle = fistGrad;
            ctx.beginPath();
            ctx.arc(-36 - armExt + shake, armY + bounce, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = gs.satanic ? '#1a0000' : '#2a1a0a';
            ctx.beginPath();
            ctx.ellipse(26 + armExt + shake, armY + bounce, 12, 9, 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = fistGrad;
            ctx.beginPath();
            ctx.arc(36 + armExt + shake, armY + bounce, 8, 0, Math.PI * 2);
            ctx.fill();

            // Impact lines when punching
            if (p) {
                ctx.strokeStyle = gs.satanic ? '#ff4400' : '#ffcc00';
                ctx.lineWidth = 2;
                const impX = 44 + shake;
                for (let i = 0; i < 4; i++) {
                    const a = (Math.PI / 3) * i - Math.PI / 3;
                    ctx.beginPath();
                    ctx.moveTo(impX + Math.cos(a) * 8, armY + bounce + Math.sin(a) * 8);
                    ctx.lineTo(impX + Math.cos(a) * 14, armY + bounce + Math.sin(a) * 14);
                    ctx.stroke();
                }
            }

            // Fire aura when satanic
            if (gs.satanic) {
                for (let i = 0; i < 3; i++) {
                    if (Math.random() > 0.4) {
                        addParticles(
                            sx + 28 + shake + (Math.random() - 0.5) * 50,
                            sy + 28 + bounce + (Math.random() - 0.5) * 50,
                            `rgb(255, ${Math.floor(Math.random() * 100)}, 0)`,
                            1, 1, 15
                        );
                    }
                }
            }

            ctx.restore();
        }

        // === DRAW ZOMBIE (IMPROVED - BIGGER) ===
        function drawZombie(sx, sy, frame) {
            const x = sx - camera.x, y = sy - camera.y;
            const wobble = Math.sin(frame * 0.15) * 3;
            const breathe = Math.sin(frame * 0.08) * 0.5;
            const cx = 13; // center x offset

            ctx.save();

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(x + cx, y + 30, 12, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            const legMove = Math.sin(frame * 0.12) * 3;
            ctx.fillStyle = '#1a3a1a';
            ctx.fillRect(x + 6, y + 23, 5, 7 + legMove);
            ctx.fillRect(x + 15, y + 23, 5, 7 - legMove);

            // Body (torn clothes)
            ctx.fillStyle = '#2a4a2a';
            ctx.beginPath();
            ctx.ellipse(x + cx, y + 19 + breathe, 9, 7, 0, 0, Math.PI * 2);
            ctx.fill();
            // Torn cloth detail
            ctx.fillStyle = '#3a5a3a';
            ctx.fillRect(x + 4, y + 16, 4, 6);
            ctx.fillRect(x + 17, y + 17, 3, 5);

            // Arms (reaching out)
            const arm = Math.sin(frame * 0.1) * 5;
            ctx.fillStyle = '#306230';
            ctx.save();
            ctx.translate(x + 3 + arm, y + 16);
            ctx.rotate(-0.4 + Math.sin(frame * 0.08) * 0.2);
            ctx.fillRect(-2, 0, 4, 11);
            ctx.fillRect(-3, 10, 3, 3);
            ctx.fillRect(1, 10, 3, 3);
            ctx.restore();
            ctx.save();
            ctx.translate(x + 22 - arm, y + 16);
            ctx.rotate(0.4 - Math.sin(frame * 0.08) * 0.2);
            ctx.fillRect(-2, 0, 4, 11);
            ctx.fillRect(-3, 10, 3, 3);
            ctx.fillRect(1, 10, 3, 3);
            ctx.restore();

            // Head
            const headGrad = ctx.createRadialGradient(x + cx + wobble, y + 8, 1, x + cx + wobble, y + 8, 11);
            headGrad.addColorStop(0, '#3a6a3a');
            headGrad.addColorStop(1, '#1a3a1a');
            ctx.fillStyle = headGrad;
            ctx.beginPath();
            ctx.arc(x + cx + wobble, y + 8, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#0a2a0a';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Eyes (glowing)
            ctx.shadowColor = '#aaff00';
            ctx.shadowBlur = 5;
            ctx.fillStyle = '#ccff00';
            ctx.beginPath();
            ctx.arc(x + 9 + wobble, y + 6, 2.5, 0, Math.PI * 2);
            ctx.arc(x + 17 + wobble, y + 6, 2.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            // Pupils
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x + 9 + wobble, y + 6, 1.2, 0, Math.PI * 2);
            ctx.arc(x + 17 + wobble, y + 6, 1.2, 0, Math.PI * 2);
            ctx.fill();

            // Mouth (drooling)
            ctx.fillStyle = '#0a1a0a';
            ctx.beginPath();
            ctx.ellipse(x + cx + wobble, y + 13, 4, 3, 0, 0, Math.PI);
            ctx.fill();
            // Drool
            ctx.fillStyle = 'rgba(100, 200, 80, 0.6)';
            ctx.fillRect(x + 12 + wobble, y + 14, 3, 4 + Math.sin(frame * 0.1) * 2);

            // Wound marks
            ctx.strokeStyle = '#4a0a0a';
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.moveTo(x + 5 + wobble, y + 3);
            ctx.lineTo(x + 9 + wobble, y + 7);
            ctx.stroke();

            ctx.restore();
        }

        // === DRAW BOSS (IMPROVED) ===
        function drawBoss(b) {
            const x = b.x - camera.x, y = b.y - camera.y;
            const shake = b.hit > 0 ? Math.sin(b.hit * 5) * 5 : 0;
            b.frame++;
            const breathe = Math.sin(b.frame * 0.04) * 3;

            ctx.save();

            // Dark aura
            ctx.shadowColor = '#00ff00';
            ctx.shadowBlur = 20 + Math.sin(b.frame * 0.05) * 10;
            ctx.fillStyle = 'rgba(0, 80, 0, 0.15)';
            ctx.beginPath();
            ctx.arc(x + 40 + shake, y + 40, 55, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.beginPath();
            ctx.ellipse(x + 40, y + 92, 40, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.fillStyle = '#0f2a0f';
            ctx.fillRect(x + 22 + shake, y + 78 + breathe, 14, 14);
            ctx.fillRect(x + 44 + shake, y + 78 + breathe, 14, 14);

            // Big zombie body with gradient
            const bodyGrad = ctx.createRadialGradient(x + 40 + shake, y + 45, 5, x + 40 + shake, y + 50, 40);
            bodyGrad.addColorStop(0, '#2a5a2a');
            bodyGrad.addColorStop(1, '#0a1f0a');
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.ellipse(x + 40 + shake, y + 50 + breathe, 35, 38, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#061506';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Spikes on shoulders
            ctx.fillStyle = '#1a3a1a';
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(x + 8 + i * 6 + shake, y + 25 + breathe);
                ctx.lineTo(x + 11 + i * 6 + shake, y + 12 + breathe);
                ctx.lineTo(x + 14 + i * 6 + shake, y + 25 + breathe);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(x + 54 + i * 6 + shake, y + 25 + breathe);
                ctx.lineTo(x + 57 + i * 6 + shake, y + 12 + breathe);
                ctx.lineTo(x + 60 + i * 6 + shake, y + 25 + breathe);
                ctx.fill();
            }

            // Ribs detail
            ctx.strokeStyle = '#0a2a0a';
            ctx.lineWidth = 1.5;
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.moveTo(x + 28 + shake, y + 38 + i * 7 + breathe);
                ctx.quadraticCurveTo(x + 40 + shake, y + 35 + i * 7 + breathe, x + 52 + shake, y + 38 + i * 7 + breathe);
                ctx.stroke();
            }

            // Head with gradient
            const headGrad = ctx.createRadialGradient(x + 40 + shake, y + 12, 3, x + 40 + shake, y + 15, 27);
            headGrad.addColorStop(0, '#2a5a2a');
            headGrad.addColorStop(1, '#0a1f0a');
            ctx.fillStyle = headGrad;
            ctx.beginPath();
            ctx.arc(x + 40 + shake, y + 15, 25, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#061506';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Scars
            ctx.strokeStyle = '#4a1a1a';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x + 25 + shake, y + 5);
            ctx.lineTo(x + 30 + shake, y + 18);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x + 55 + shake, y + 8);
            ctx.lineTo(x + 48 + shake, y + 20);
            ctx.stroke();

            // Glowing eyes
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(x + 30 + shake, y + 10, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 50 + shake, y + 10, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#660000';
            ctx.beginPath();
            ctx.arc(x + 30 + shake, y + 10, 2, 0, Math.PI * 2);
            ctx.arc(x + 50 + shake, y + 10, 2, 0, Math.PI * 2);
            ctx.fill();

            // Mouth with teeth
            ctx.fillStyle = '#0a0a0a';
            ctx.beginPath();
            ctx.moveTo(x + 25 + shake, y + 25);
            ctx.quadraticCurveTo(x + 40 + shake, y + 40, x + 55 + shake, y + 25);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#ddd';
            for (let i = 0; i < 6; i++) {
                const tType = i % 2 === 0;
                ctx.beginPath();
                ctx.moveTo(x + 27 + i * 5 + shake, y + 25);
                ctx.lineTo(x + 29.5 + i * 5 + shake, y + (tType ? 30 : 22));
                ctx.lineTo(x + 32 + i * 5 + shake, y + 25);
                ctx.fill();
            }
            // Drool
            ctx.fillStyle = 'rgba(80, 180, 60, 0.7)';
            ctx.beginPath();
            ctx.moveTo(x + 35 + shake, y + 32);
            ctx.quadraticCurveTo(x + 36 + shake, y + 42 + Math.sin(b.frame * 0.1) * 3, x + 34 + shake, y + 48);
            ctx.lineTo(x + 38 + shake, y + 48);
            ctx.quadraticCurveTo(x + 39 + shake, y + 42, x + 37 + shake, y + 32);
            ctx.fill();

            // Arms (muscular)
            const armWave = Math.sin(b.frame * 0.08) * 8;
            ctx.fillStyle = '#1a3a1a';
            ctx.beginPath();
            ctx.ellipse(x - 5 + armWave + shake, y + 35 + breathe, 14, 8, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x - 15 + armWave + shake, y + 40 + breathe, 8, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + 85 - armWave + shake, y + 35 + breathe, 14, 8, 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + 95 - armWave + shake, y + 40 + breathe, 8, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Toxic particles
            if (Math.random() > 0.6) {
                addParticles(
                    b.x + 40 + (Math.random() - 0.5) * 60,
                    b.y + 30 + (Math.random() - 0.5) * 40,
                    '#44ff44', 1, 0.5, 20
                );
            }

            ctx.restore();

            // Health bar
            bossHealthBar.style.width = (b.hp / b.maxHp * 100) + '%';
        }

        // === DRAW MINI-BOSS ZOMBIE ===
        function drawMiniBoss(mb) {
            const x = mb.x - camera.x, y = mb.y - camera.y;
            const shake = mb.hit > 0 ? Math.sin(mb.hit * 5) * 3 : 0;
            const breathe = Math.sin(mb.frame * 0.05) * 2;
            const wobble = Math.sin(mb.frame * 0.1) * 2;

            ctx.save();

            // Red/orange warning aura
            ctx.shadowColor = '#ff4400';
            ctx.shadowBlur = 12 + Math.sin(mb.frame * 0.08) * 6;
            ctx.fillStyle = 'rgba(255, 60, 0, 0.1)';
            ctx.beginPath();
            ctx.arc(x + 20 + shake, y + 22, 32, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.beginPath();
            ctx.ellipse(x + 20, y + 46, 18, 5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Legs (thick)
            ctx.fillStyle = '#1a2a1a';
            ctx.fillRect(x + 8 + shake, y + 36 + breathe, 8, 10);
            ctx.fillRect(x + 24 + shake, y + 36 + breathe, 8, 10);

            // Body (bigger than regular zombie)
            const bodyGrad = ctx.createRadialGradient(x + 20 + shake, y + 26, 3, x + 20 + shake, y + 28, 18);
            bodyGrad.addColorStop(0, '#3a5a3a');
            bodyGrad.addColorStop(1, '#1a2a1a');
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.ellipse(x + 20 + shake, y + 28 + breathe, 16, 14, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#0a1a0a';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Armor plates
            ctx.fillStyle = '#2a3a2a';
            ctx.fillRect(x + 8 + shake, y + 18 + breathe, 6, 12);
            ctx.fillRect(x + 26 + shake, y + 18 + breathe, 6, 12);
            ctx.strokeStyle = '#4a5a4a';
            ctx.lineWidth = 0.8;
            ctx.strokeRect(x + 8 + shake, y + 18 + breathe, 6, 12);
            ctx.strokeRect(x + 26 + shake, y + 18 + breathe, 6, 12);

            // Head (bigger)
            const headGrad = ctx.createRadialGradient(x + 20 + wobble + shake, y + 10, 1, x + 20 + wobble + shake, y + 10, 14);
            headGrad.addColorStop(0, '#4a7a4a');
            headGrad.addColorStop(1, '#1a3a1a');
            ctx.fillStyle = headGrad;
            ctx.beginPath();
            ctx.arc(x + 20 + wobble + shake, y + 10, 13, 0, Math.PI * 2);
            ctx.fill();

            // Crown/spikes on head
            ctx.fillStyle = '#2a4a2a';
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(x + 10 + i * 8 + shake, y + 2 + breathe);
                ctx.lineTo(x + 14 + i * 8 + shake, y - 8 + breathe);
                ctx.lineTo(x + 18 + i * 8 + shake, y + 2 + breathe);
                ctx.fill();
            }

            // Eyes (angry red glow)
            ctx.shadowColor = '#ff2200';
            ctx.shadowBlur = 10;
            ctx.fillStyle = '#ff4400';
            ctx.beginPath();
            ctx.arc(x + 14 + wobble + shake, y + 7, 3.5, 0, Math.PI * 2);
            ctx.arc(x + 26 + wobble + shake, y + 7, 3.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#220000';
            ctx.beginPath();
            ctx.arc(x + 14 + wobble + shake, y + 7, 1.5, 0, Math.PI * 2);
            ctx.arc(x + 26 + wobble + shake, y + 7, 1.5, 0, Math.PI * 2);
            ctx.fill();

            // Mouth (snarling)
            ctx.fillStyle = '#0a0a0a';
            ctx.beginPath();
            ctx.ellipse(x + 20 + wobble + shake, y + 16, 6, 4, 0, 0, Math.PI);
            ctx.fill();
            // Fangs
            ctx.fillStyle = '#ddd';
            ctx.beginPath();
            ctx.moveTo(x + 15 + wobble + shake, y + 14); ctx.lineTo(x + 17 + wobble + shake, y + 19); ctx.lineTo(x + 19 + wobble + shake, y + 14);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(x + 21 + wobble + shake, y + 14); ctx.lineTo(x + 23 + wobble + shake, y + 19); ctx.lineTo(x + 25 + wobble + shake, y + 14);
            ctx.fill();

            // Arms (muscular)
            const armWave = Math.sin(mb.frame * 0.1) * 6;
            ctx.fillStyle = '#2a4a2a';
            ctx.beginPath();
            ctx.ellipse(x - 2 + armWave + shake, y + 24 + breathe, 8, 5, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + 42 - armWave + shake, y + 24 + breathe, 8, 5, 0.3, 0, Math.PI * 2);
            ctx.fill();
            // Fists
            ctx.fillStyle = '#3a5a3a';
            ctx.beginPath();
            ctx.arc(x - 8 + armWave + shake, y + 26 + breathe, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 48 - armWave + shake, y + 26 + breathe, 5, 0, Math.PI * 2);
            ctx.fill();

            // HP bar above head
            const barW = 30;
            const barH = 4;
            const hpPct = mb.hp / mb.maxHp;
            ctx.fillStyle = '#333';
            ctx.fillRect(x + 5 + shake, y - 14, barW, barH);
            ctx.fillStyle = hpPct > 0.5 ? '#ff6600' : '#ff0000';
            ctx.fillRect(x + 5 + shake, y - 14, barW * hpPct, barH);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.strokeRect(x + 5 + shake, y - 14, barW, barH);

            // Name tag
            ctx.font = 'bold 8px Courier New';
            ctx.textAlign = 'center';
            ctx.fillStyle = '#ff6600';
            ctx.fillText(mb.name, x + 20, y - 17);

            // Hit flash
            if (mb.hit > 0) {
                mb.hit--;
                ctx.fillStyle = 'rgba(255, 100, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(x + 20 + shake, y + 22, 20, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }

        // Spawn mini-boss zombie
        function spawnMiniBoss() {
            if (gs.over || gs.paused || gs.won || miniBosses.length >= 2) return;

            const dirs = [[0, -30], [0, WORLD.h + 30], [-30, WORLD.h / 2], [WORLD.w + 30, WORLD.h / 2]];
            const [bx, by] = dirs[Math.floor(Math.random() * 4)];
            const x = bx === 0 || bx === WORLD.w + 30 ? bx : 50 + Math.random() * (WORLD.w - 100);
            const y = by === WORLD.h / 2 ? 50 + Math.random() * (WORLD.h - 100) : by;
            const name = MINIBOSS_NAMES[Math.floor(Math.random() * MINIBOSS_NAMES.length)];
            const hp = 15 + gs.room * 5;

            miniBosses.push({
                x, y, w: 40, h: 46, speed: 0.6 + gs.room * 0.04,
                hp, maxHp: hp, frame: 0, hit: 0, name
            });

            showSpeech(MINIBOSS_GORILLA_TAUNT[Math.floor(Math.random() * MINIBOSS_GORILLA_TAUNT.length)]);
            addFloat(x, y - 20, `‚ö†Ô∏è ${name}`);
        }

        // === DRAW APOCALYPTIC OBSTACLES ===
        function drawObstacles() {
            obstacles.forEach(o => {
                const x = o.x - camera.x, y = o.y - camera.y;
                if (x < -100 || x > canvas.width + 100 || y < -100 || y > canvas.height + 100) return;

                ctx.save();

                // Drop shadow for all obstacles
                if (!o.noCollide) {
                    ctx.fillStyle = 'rgba(0,0,0,0.25)';
                    ctx.beginPath();
                    ctx.ellipse(x + o.w / 2 + 3, y + o.h + 2, o.w / 2.2, 5, 0, 0, Math.PI * 2);
                    ctx.fill();
                }

                switch (o.type) {
                    case 'ruin': { // Ruinas de edificio - con gradiente y m√°s detalle
                        const ruinGrad = ctx.createLinearGradient(x, y, x, y + o.h);
                        ruinGrad.addColorStop(0, '#3a3a3a');
                        ruinGrad.addColorStop(1, '#1a1a1a');
                        ctx.fillStyle = ruinGrad;
                        // Forma irregular (no perfectamente rectangular)
                        ctx.beginPath();
                        ctx.moveTo(x + 3, y + o.h);
                        ctx.lineTo(x, y + 8);
                        ctx.lineTo(x + 5, y);
                        ctx.lineTo(x + o.w - 8, y + 3);
                        ctx.lineTo(x + o.w, y + 10);
                        ctx.lineTo(x + o.w - 2, y + o.h);
                        ctx.closePath();
                        ctx.fill();
                        ctx.strokeStyle = '#0a0a0a';
                        ctx.lineWidth = 1.5;
                        ctx.stroke();
                        // Grietas profundas
                        ctx.strokeStyle = 'rgba(0,0,0,0.5)';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.moveTo(x + 12, y + 2); ctx.lineTo(x + 18, y + o.h * 0.4);
                        ctx.lineTo(x + 15, y + o.h * 0.7); ctx.lineTo(x + 22, y + o.h);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(x + o.w - 10, y + 5); ctx.lineTo(x + o.w - 18, y + o.h * 0.5);
                        ctx.stroke();
                        // Ventanas rotas con brillo interno
                        ctx.fillStyle = '#050505';
                        ctx.fillRect(x + 8, y + 10, 12, 14);
                        ctx.fillRect(x + o.w - 22, y + 10, 12, 14);
                        ctx.fillStyle = 'rgba(40, 60, 40, 0.15)';
                        ctx.fillRect(x + 9, y + 11, 4, 5);
                        ctx.fillRect(x + o.w - 21, y + 11, 4, 5);
                        // Ladrillos expuestos
                        ctx.fillStyle = '#4a2a1a';
                        ctx.fillRect(x + o.w - 15, y + o.h - 12, 8, 4);
                        ctx.fillRect(x + o.w - 12, y + o.h - 7, 6, 3);
                        ctx.fillRect(x + 3, y + o.h - 10, 7, 3);
                        break;
                    }

                    case 'tree': { // √Årbol quemado - con corteza texturizada
                        // Tronco con gradiente
                        const trunkGrad = ctx.createLinearGradient(x + 10, y + 20, x + 20, y + 20);
                        trunkGrad.addColorStop(0, '#2a1a08');
                        trunkGrad.addColorStop(0.5, '#1a1208');
                        trunkGrad.addColorStop(1, '#0f0a04');
                        ctx.fillStyle = trunkGrad;
                        ctx.beginPath();
                        ctx.moveTo(x + 9, y + 58);
                        ctx.lineTo(x + 11, y + 22);
                        ctx.lineTo(x + 14, y + 18);
                        ctx.lineTo(x + 20, y + 20);
                        ctx.lineTo(x + 22, y + 60);
                        ctx.closePath();
                        ctx.fill();
                        // Ra√≠ces
                        ctx.strokeStyle = '#1a1208';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x + 9, y + 56); ctx.lineTo(x + 3, y + 62);
                        ctx.moveTo(x + 22, y + 58); ctx.lineTo(x + 27, y + 64);
                        ctx.stroke();
                        // Ramas muertas con variable thickness
                        ctx.strokeStyle = '#2a1a0a';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(x + 15, y + 25); ctx.lineTo(x + 4, y + 8);
                        ctx.stroke();
                        ctx.lineWidth = 2.5;
                        ctx.beginPath();
                        ctx.moveTo(x + 15, y + 23); ctx.lineTo(x + 26, y + 4);
                        ctx.stroke();
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x + 14, y + 33); ctx.lineTo(x, y + 28);
                        ctx.moveTo(x + 16, y + 35); ctx.lineTo(x + 29, y + 26);
                        ctx.stroke();
                        // Carb√≥n / holl√≠n
                        ctx.fillStyle = 'rgba(0,0,0,0.2)';
                        ctx.beginPath();
                        ctx.ellipse(x + 15, y + 60, 8, 3, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Occasional ember
                        if (Math.random() > 0.92) {
                            ctx.fillStyle = 'rgba(255, 100, 0, 0.6)';
                            ctx.beginPath();
                            ctx.arc(x + 5 + Math.random() * 20, y + 5 + Math.random() * 15, 1.5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                    }

                    case 'tomb': { // L√°pida - m√°s detallada
                        // Base de piedra
                        ctx.fillStyle = '#2a2a2a';
                        ctx.fillRect(x + 3, y + 36, 29, 9);
                        // L√°pida con gradiente
                        const tombGrad = ctx.createLinearGradient(x + 7, y, x + 28, y + 35);
                        tombGrad.addColorStop(0, '#4a4a4a');
                        tombGrad.addColorStop(1, '#2a2a2a');
                        ctx.fillStyle = tombGrad;
                        ctx.beginPath();
                        ctx.moveTo(x + 7, y + 36);
                        ctx.lineTo(x + 7, y + 13);
                        ctx.quadraticCurveTo(x + 17, y - 2, x + 28, y + 13);
                        ctx.lineTo(x + 28, y + 36);
                        ctx.fill();
                        ctx.strokeStyle = '#1a1a1a';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                        // Highlight edge
                        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
                        ctx.beginPath();
                        ctx.moveTo(x + 8, y + 35);
                        ctx.lineTo(x + 8, y + 14);
                        ctx.quadraticCurveTo(x + 17, y, x + 27, y + 14);
                        ctx.stroke();
                        // RIP text
                        ctx.fillStyle = '#0a0a0a';
                        ctx.font = 'bold 9px Courier';
                        ctx.textAlign = 'center';
                        ctx.fillText('RIP', x + 17, y + 22);
                        // Cruz peque√±a
                        ctx.strokeStyle = '#1a1a1a';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.moveTo(x + 17, y + 7); ctx.lineTo(x + 17, y + 15);
                        ctx.moveTo(x + 14, y + 10); ctx.lineTo(x + 20, y + 10);
                        ctx.stroke();
                        // Musgo
                        ctx.fillStyle = 'rgba(30, 60, 20, 0.3)';
                        ctx.beginPath();
                        ctx.ellipse(x + 10, y + 34, 5, 3, 0, 0, Math.PI);
                        ctx.fill();
                        break;
                    }

                    case 'car': { // Auto destruido - m√°s realista
                        // Sombra del auto
                        ctx.fillStyle = 'rgba(0,0,0,0.3)';
                        ctx.beginPath();
                        ctx.ellipse(x + o.w / 2, y + 36, o.w / 2 + 3, 6, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Cuerpo con gradiente
                        const carGrad = ctx.createLinearGradient(x, y + 10, x, y + 30);
                        carGrad.addColorStop(0, '#353535');
                        carGrad.addColorStop(1, '#1a1a1a');
                        ctx.fillStyle = carGrad;
                        ctx.fillRect(x + 2, y + 10, o.w - 4, 20);
                        // Techo aplastado
                        ctx.fillStyle = '#2a2a2a';
                        ctx.beginPath();
                        ctx.moveTo(x + 15, y + 10);
                        ctx.lineTo(x + 18, y + 2);
                        ctx.lineTo(x + 48, y);
                        ctx.lineTo(x + 50, y + 10);
                        ctx.closePath();
                        ctx.fill();
                        // Ventanas rotas
                        ctx.fillStyle = 'rgba(40, 60, 80, 0.3)';
                        ctx.fillRect(x + 20, y + 3, 10, 7);
                        ctx.fillRect(x + 35, y + 2, 10, 7);
                        // Ruedas
                        ctx.fillStyle = '#111';
                        ctx.beginPath();
                        ctx.arc(x + 14, y + 32, 7, 0, Math.PI * 2);
                        ctx.arc(x + o.w - 14, y + 32, 7, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#222';
                        ctx.beginPath();
                        ctx.arc(x + 14, y + 32, 3, 0, Math.PI * 2);
                        ctx.arc(x + o.w - 14, y + 32, 3, 0, Math.PI * 2);
                        ctx.fill();
                        // Oxido
                        ctx.fillStyle = 'rgba(80, 40, 10, 0.3)';
                        ctx.beginPath();
                        ctx.ellipse(x + 30, y + 18, 8, 4, 0.2, 0, Math.PI * 2);
                        ctx.fill();
                        // Humo/fuego
                        if (Math.random() > 0.6) {
                            ctx.fillStyle = `rgba(80, 80, 80, ${0.2 + Math.random() * 0.3})`;
                            ctx.beginPath();
                            ctx.arc(x + 10 + Math.random() * 10, y - 3, 5 + Math.random() * 6, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                    }

                    case 'blood': { // Charco de sangre
                        ctx.fillStyle = 'rgba(60, 8, 8, 0.6)';
                        ctx.beginPath();
                        ctx.ellipse(x + o.w / 2, y + o.h / 2, o.w / 2, o.h / 3, 0.1, 0, Math.PI * 2);
                        ctx.fill();
                        // Reflection/shine
                        ctx.fillStyle = 'rgba(100, 15, 15, 0.3)';
                        ctx.beginPath();
                        ctx.ellipse(x + o.w / 2 - 3, y + o.h / 2 - 2, o.w / 5, o.h / 7, -0.2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = 'rgba(40, 4, 4, 0.4)';
                        ctx.beginPath();
                        ctx.ellipse(x + o.w / 2 + 6, y + o.h / 2 + 4, o.w / 4, o.h / 5, 0.3, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    }

                    case 'barrel': { // Barril t√≥xico - con brillo y goteo
                        // Barril body con gradiente cil√≠ndrico
                        const barrelGrad = ctx.createLinearGradient(x, y, x + o.w, y);
                        barrelGrad.addColorStop(0, '#2a2a00');
                        barrelGrad.addColorStop(0.4, '#4a4a00');
                        barrelGrad.addColorStop(0.6, '#3a3a00');
                        barrelGrad.addColorStop(1, '#1a1a00');
                        ctx.fillStyle = barrelGrad;
                        ctx.beginPath();
                        ctx.ellipse(x + o.w / 2, y + 4, o.w / 2, 4, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillRect(x, y + 4, o.w, o.h - 8);
                        ctx.beginPath();
                        ctx.ellipse(x + o.w / 2, y + o.h - 4, o.w / 2, 4, 0, 0, Math.PI * 2);
                        ctx.fill();
                        // Bandas met√°licas
                        ctx.strokeStyle = '#5a5a00';
                        ctx.lineWidth = 1.5;
                        ctx.beginPath();
                        ctx.moveTo(x, y + 8); ctx.lineTo(x + o.w, y + 8);
                        ctx.moveTo(x, y + o.h - 8); ctx.lineTo(x + o.w, y + o.h - 8);
                        ctx.stroke();
                        // S√≠mbolo t√≥xico (tri√°ngulo de peligro)
                        ctx.fillStyle = '#aaa800';
                        ctx.beginPath();
                        ctx.moveTo(x + o.w / 2, y + o.h / 2 - 5);
                        ctx.lineTo(x + o.w / 2 - 5, y + o.h / 2 + 4);
                        ctx.lineTo(x + o.w / 2 + 5, y + o.h / 2 + 4);
                        ctx.closePath();
                        ctx.fill();
                        ctx.fillStyle = '#2a2a00';
                        ctx.beginPath();
                        ctx.arc(x + o.w / 2, y + o.h / 2 + 1, 2, 0, Math.PI * 2);
                        ctx.fill();
                        // Goteo t√≥xico animado
                        ctx.fillStyle = 'rgba(120, 180, 0, 0.6)';
                        const dripH = 6 + Math.sin(Date.now() * 0.003) * 4;
                        ctx.beginPath();
                        ctx.moveTo(x + o.w - 2, y + o.h - 4);
                        ctx.quadraticCurveTo(x + o.w, y + o.h + dripH, x + o.w - 4, y + o.h + dripH + 2);
                        ctx.quadraticCurveTo(x + o.w - 6, y + o.h + dripH, x + o.w - 4, y + o.h - 4);
                        ctx.fill();
                        // Toxic glow
                        ctx.shadowColor = '#aaff00';
                        ctx.shadowBlur = 4;
                        ctx.fillStyle = 'rgba(120, 200, 0, 0.1)';
                        ctx.beginPath();
                        ctx.arc(x + o.w / 2, y + o.h + 3, 8, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        break;
                    }

                    case 'decor_blood': // Sangre decorativa (no bloquea)
                        ctx.fillStyle = 'rgba(70, 8, 8, 0.35)';
                        ctx.beginPath();
                        ctx.ellipse(x + o.w / 2, y + o.h / 2, o.w / 2, o.h / 3, o.x * 0.01, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = 'rgba(90, 5, 5, 0.2)';
                        ctx.beginPath();
                        ctx.ellipse(x + o.w / 2 + 4, y + o.h / 2 - 2, o.w / 4, o.h / 5, -0.3, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }

                ctx.restore();
            });
        }

        // === DRAW STAR (Demonic Powerup for Gorilla) ===
        function drawStar(sx, sy, size, pulse) {
            const x = sx - camera.x, y = sy - camera.y;
            const glow = Math.sin(pulse * 0.1) * 0.5 + 0.5;
            const scale = 1 + glow * 0.3;
            const rot = pulse * 0.03;

            ctx.save();
            ctx.translate(x + size / 2, y + size / 2);
            ctx.rotate(rot);
            ctx.scale(scale, scale);

            // Outer glow ring (red/orange for demonic)
            ctx.shadowColor = '#ff4400';
            ctx.shadowBlur = 15 + glow * 15;
            ctx.strokeStyle = `rgba(255, 68, 0, ${0.3 + glow * 0.4})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.7, 0, Math.PI * 2);
            ctx.stroke();

            // Star shape (5-pointed, infernal)
            ctx.fillStyle = '#ff4400';
            ctx.strokeStyle = '#aa2200';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let i = 0; i < 10; i++) {
                const angle = (Math.PI * 2 / 10) * i - Math.PI / 2;
                const r = i % 2 === 0 ? size * 0.5 : size * 0.22;
                const px = Math.cos(angle) * r;
                const py = Math.sin(angle) * r;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Inner highlight
            ctx.fillStyle = '#ff8844';
            ctx.beginPath();
            ctx.arc(0, -2, size * 0.12, 0, Math.PI * 2);
            ctx.fill();

            // Devil emoji in center
            ctx.shadowBlur = 0;
            ctx.font = `${size * 0.4}px serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('üëπ', 0, 1);

            ctx.restore();

            // Fire sparkle particles
            if (Math.random() > 0.7) {
                addParticles(sx + size / 2, sy + size / 2, Math.random() > 0.5 ? '#ff4400' : '#ff6600', 1, 0.8, 15);
            }
        }

        // === RESIDENT EVIL STYLE FLOOR (IMPROVED) ===
        function drawFloor() {
            const tileSize = 60;
            const startX = Math.floor(camera.x / tileSize) * tileSize;
            const startY = Math.floor(camera.y / tileSize) * tileSize;

            // Room-based color themes
            const roomColors = [
                { dark: [30, 28, 28], light: [38, 35, 35] },   // R1: gris oscuro
                { dark: [25, 30, 25], light: [32, 38, 32] },   // R2: verde hospital
                { dark: [32, 25, 25], light: [40, 32, 32] },   // R3: rojo sangre
                { dark: [28, 22, 32], light: [36, 28, 40] },   // R4: p√∫rpura boss
                { dark: [22, 28, 32], light: [28, 35, 40] },   // R5: azul fr√≠o
                { dark: [32, 28, 20], light: [40, 35, 26] },   // R6: oxidado
                { dark: [20, 12, 12], light: [28, 16, 16] },   // R7: infierno
            ];
            const rc = roomColors[Math.min(gs.room - 1, 6)];

            for (let x = startX - tileSize; x < camera.x + canvas.width + tileSize; x += tileSize) {
                for (let y = startY - tileSize; y < camera.y + canvas.height + tileSize; y += tileSize) {
                    const screenX = x - camera.x;
                    const screenY = y - camera.y;

                    const isDark = ((x / tileSize + y / tileSize) % 2) === 0;
                    const seed = Math.abs((x * 7 + y * 13)) % 100;
                    const tint = seed % 6;
                    const base = isDark ? rc.dark : rc.light;
                    ctx.fillStyle = `rgb(${base[0] + tint}, ${base[1] + tint}, ${base[2] + tint})`;
                    ctx.fillRect(screenX, screenY, tileSize, tileSize);

                    // Grout lines
                    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
                    ctx.lineWidth = 1.5;
                    ctx.strokeRect(screenX, screenY, tileSize, tileSize);

                    // Inner tile highlight (subtle 3D bevel)
                    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.04)' : 'rgba(255,255,255,0.06)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(screenX + 2, screenY + tileSize - 2);
                    ctx.lineTo(screenX + 2, screenY + 2);
                    ctx.lineTo(screenX + tileSize - 2, screenY + 2);
                    ctx.stroke();
                    // Bottom-right shadow bevel
                    ctx.strokeStyle = 'rgba(0,0,0,0.15)';
                    ctx.beginPath();
                    ctx.moveTo(screenX + tileSize - 2, screenY + 2);
                    ctx.lineTo(screenX + tileSize - 2, screenY + tileSize - 2);
                    ctx.lineTo(screenX + 2, screenY + tileSize - 2);
                    ctx.stroke();

                    // Cracks (seeded by position)
                    if (seed < 12) {
                        ctx.strokeStyle = 'rgba(0,0,0,0.4)';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(screenX + 10, screenY + 15);
                        ctx.lineTo(screenX + 25, screenY + 30);
                        ctx.lineTo(screenX + 22, screenY + 45);
                        ctx.lineTo(screenX + 40, screenY + 55);
                        ctx.stroke();
                    }
                    if (seed > 22 && seed < 28) {
                        ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                        ctx.lineWidth = 0.8;
                        ctx.beginPath();
                        ctx.moveTo(screenX + 50, screenY + 5);
                        ctx.lineTo(screenX + 38, screenY + 22);
                        ctx.lineTo(screenX + 42, screenY + 35);
                        ctx.lineTo(screenX + 25, screenY + 52);
                        ctx.stroke();
                    }

                    // Blood stains (room 3+ more blood)
                    if (seed > 85 && seed < (85 + gs.room * 1.5)) {
                        ctx.fillStyle = `rgba(60, 8, 8, ${0.3 + gs.room * 0.03})`;
                        ctx.beginPath();
                        ctx.ellipse(screenX + 30, screenY + 30, 14, 9, seed * 0.1, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = 'rgba(80, 5, 5, 0.2)';
                        ctx.beginPath();
                        ctx.arc(screenX + 18, screenY + 22, 4, 0, Math.PI * 2);
                        ctx.fill();
                        // Blood drops
                        ctx.fillStyle = 'rgba(90, 5, 5, 0.25)';
                        ctx.beginPath();
                        ctx.arc(screenX + 42, screenY + 38, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Dirt/moss marks
                    if (seed > 40 && seed < 50) {
                        ctx.fillStyle = `rgba(${30 + rc.dark[1]}, ${35 + rc.dark[1]}, ${20 + rc.dark[2]}, 0.2)`;
                        ctx.beginPath();
                        ctx.ellipse(screenX + 20 + seed % 20, screenY + 15 + seed % 15, 10, 6, seed * 0.05, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Scratch marks (higher rooms = more damage)
                    if (seed > 60 && seed < 60 + gs.room) {
                        ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                        ctx.lineWidth = 0.6;
                        ctx.beginPath();
                        for (let s = 0; s < 3; s++) {
                            ctx.moveTo(screenX + 15 + s * 8, screenY + 10);
                            ctx.lineTo(screenX + 20 + s * 8, screenY + 50);
                        }
                        ctx.stroke();
                    }
                }
            }

            // Dynamic lighting around player
            const plx = player.x - camera.x + player.w / 2;
            const ply = player.y - camera.y + player.h / 2;
            const lightRadius = 200 + (gs.satanic ? 80 : 0);
            const lightColor = gs.satanic ? 'rgba(255, 80, 30, 0.08)' : 'rgba(255, 200, 100, 0.06)';
            const lightGrad = ctx.createRadialGradient(plx, ply, 30, plx, ply, lightRadius);
            lightGrad.addColorStop(0, lightColor);
            lightGrad.addColorStop(0.5, 'rgba(0,0,0,0)');
            lightGrad.addColorStop(1, `rgba(0,0,0,${0.3 + gs.room * 0.02})`);
            ctx.fillStyle = lightGrad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Gorilla also emits light
            if (gs.goriActive) {
                const glx = gorilla.x + 28 - camera.x;
                const gly = gorilla.y + 28 - camera.y;
                const gLightGrad = ctx.createRadialGradient(glx, gly, 10, glx, gly, 80);
                gLightGrad.addColorStop(0, gs.satanic ? 'rgba(255, 50, 0, 0.08)' : 'rgba(200, 150, 100, 0.04)');
                gLightGrad.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = gLightGrad;
                ctx.fillRect(glx - 80, gly - 80, 160, 160);
            }
        }

        // === SCANLINES + VIGNETTE ===
        function drawScanlines() {
            ctx.fillStyle = 'rgba(0,0,0,0.05)';
            for (let y = 0; y < canvas.height; y += 3) {
                ctx.fillRect(0, y, canvas.width, 1);
            }
            // Vignette
            const vig = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, canvas.width * 0.3,
                canvas.width / 2, canvas.height / 2, canvas.width * 0.75
            );
            vig.addColorStop(0, 'rgba(0,0,0,0)');
            vig.addColorStop(1, 'rgba(0,0,0,0.4)');
            ctx.fillStyle = vig;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Floating text
        function addFloat(x, y, text, color) { gs.floats.push({ x, y, text, life: 50, vy: -2, color: color || null }); }

        function drawFloats() {
            gs.floats = gs.floats.filter(f => {
                f.y += f.vy;
                f.life--;
                if (f.life > 0) {
                    const x = f.x - camera.x, y = f.y - camera.y;
                    ctx.save();
                    // Bigger font for combo/special messages
                    const isSpecial = f.text.length > 5;
                    ctx.font = isSpecial ? 'bold 15px Courier New' : 'bold 13px Courier New';
                    ctx.textAlign = 'center';
                    const alpha = f.life / 50;
                    if (f.color) {
                        ctx.shadowColor = f.color;
                        ctx.shadowBlur = 8;
                        ctx.fillStyle = f.color.replace(')', `,${alpha})`).replace('rgb', 'rgba') || `rgba(255,255,100,${alpha})`;
                    } else {
                        ctx.fillStyle = `rgba(255,255,255,${alpha})`;
                    }
                    ctx.strokeStyle = `rgba(0,0,0,${alpha})`;
                    ctx.lineWidth = 2;
                    ctx.strokeText(f.text, x, y);
                    ctx.fillText(f.text, x, y);
                    ctx.restore();
                    return true;
                }
                return false;
            });
        }

        // üî• Draw combo counter HUD
        function drawComboHUD() {
            if (gs.combo >= 3) {
                ctx.save();
                const comboText = `${gs.combo}x COMBO`;
                // Find current tier
                let tier = COMBO_MSGS[0];
                for (let i = COMBO_MSGS.length - 1; i >= 0; i--) {
                    if (gs.combo >= COMBO_MSGS[i].min) { tier = COMBO_MSGS[i]; break; }
                }
                const pulse = 1 + Math.sin(Date.now() * 0.01) * 0.1;
                ctx.font = `bold ${Math.floor(22 * pulse)}px Courier New`;
                ctx.textAlign = 'center';
                ctx.shadowColor = tier.color;
                ctx.shadowBlur = 15;
                ctx.fillStyle = tier.color;
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(comboText, canvas.width / 2, 60);
                ctx.fillText(comboText, canvas.width / 2, 60);
                // Smaller tier text below
                ctx.font = 'bold 12px Courier New';
                ctx.fillStyle = '#fff';
                ctx.strokeText(tier.text, canvas.width / 2, 78);
                ctx.fillText(tier.text, canvas.width / 2, 78);
                ctx.restore();
            }
            // Combo timer decay
            if (gs.comboTimer > 0) {
                gs.comboTimer--;
                if (gs.comboTimer <= 0) gs.combo = 0;
            }
        }

        // Gorilla speech
        function showSpeech(text) {
            gorillaSpeech.innerText = text;
            gorillaSpeech.style.display = 'block';
            gs.goriSpeechTimer = 180;
        }

        function updateSpeech() {
            if (gs.goriSpeechTimer > 0) {
                gs.goriSpeechTimer--;
                const rect = container.getBoundingClientRect();
                const sx = (gorilla.x - camera.x) / canvas.width * rect.width + 10;
                const sy = (gorilla.y - camera.y - 60) / canvas.height * rect.height;
                gorillaSpeech.style.left = sx + 'px';
                gorillaSpeech.style.top = Math.max(0, sy) + 'px';
                if (gs.goriSpeechTimer <= 0) gorillaSpeech.style.display = 'none';
            }
        }

        // Gorilla AI
        function updateGorilla() {
            if (!gs.goriActive) return;

            gorilla.walk++;
            if (gorilla.punch > 0) gorilla.punch--;
            if (gorilla.attackCooldown > 0) gorilla.attackCooldown--;

            // Satanic timer from star powerup
            if (gs.satTimer > 0) {
                gs.satTimer--;
                if (gs.satTimer <= 0 && !boss) {
                    gs.satanic = false;
                    gorilla.speed = 3;
                    showSpeech("Ya me calm√©... por ahora ü¶çüò§");
                    updateUI();
                }
            }
            // Always satanic against room boss
            if (boss) gs.satanic = true;

            // Find target: priority = boss > miniBoss > zombie
            let target = null;
            let minDist = Infinity;
            let targetType = 'zombie';

            if (boss) {
                target = boss;
                minDist = Math.hypot(boss.x - gorilla.x, boss.y - gorilla.y);
                targetType = 'boss';
            }

            // Mini-bosses get priority over regular zombies
            miniBosses.forEach(mb => {
                const d = Math.hypot(mb.x - gorilla.x, mb.y - gorilla.y);
                if (d < minDist || targetType === 'zombie') {
                    if (targetType !== 'boss') { minDist = d; target = mb; targetType = 'miniboss'; }
                }
            });

            if (targetType === 'zombie') {
                zombies.forEach(z => {
                    const d = Math.hypot(z.x - gorilla.x, z.y - gorilla.y);
                    if (d < minDist) { minDist = d; target = z; }
                });
            }

            if (target) {
                const dx = target.x - gorilla.x;
                const dy = target.y - gorilla.y;
                const angle = Math.atan2(dy, dx);
                const spd = minDist < 80 ? gorilla.speed * 1.1 : gorilla.speed;

                gorilla.x += Math.cos(angle) * spd;
                gorilla.y += Math.sin(angle) * spd;

                // Collision - with attack cooldown
                if (collide(gorilla, target) && gorilla.attackCooldown <= 0) {
                    gorilla.punch = 18;
                    gorilla.attackCooldown = 35; // ~0.6s between attacks

                    if (target === boss) {
                        boss.hp -= (gs.satanic ? 3 : 1);
                        boss.hit = 10;
                        addFloat(boss.x + 40, boss.y, gs.satanic ? '-3 üî•' : '-1');
                        showSpeech(gs.satanic ? "MUERE DEMONIO CULIAO üëπüî•" : GORILLA_PHRASES[Math.floor(Math.random() * GORILLA_PHRASES.length)]);

                        if (boss.hp <= 0) {
                            gs.score += 50;
                            addFloat(boss.x + 40, boss.y, '+50 BOSS!');
                            boss = null;
                            bossHealthEl.style.display = 'none';
                            bossLabel.style.display = 'none';
                            if (gs.satTimer <= 0) gs.satanic = false;
                        }
                    } else if (miniBosses.includes(target)) {
                        // Gorilla hits mini-boss
                        target.hp -= (gs.satanic ? 2 : 1);
                        target.hit = 10;
                        addFloat(target.x + 20, target.y, gs.satanic ? '-2 üî•' : '-1');
                        showSpeech(MINIBOSS_GORILLA_TAUNT[Math.floor(Math.random() * MINIBOSS_GORILLA_TAUNT.length)]);
                        addParticles(target.x + 20, target.y + 20, gs.satanic ? '#ff4400' : '#ffaa00', 8, 2.5, 20);

                        if (target.hp <= 0) {
                            gs.score += 25;
                            gs.kills += 3;
                            addFloat(target.x + 20, target.y, '+25 MINI-BOSS! üíÄ');
                            addParticles(target.x + 20, target.y + 20, '#ff0000', 20, 3, 35);
                            addParticles(target.x + 20, target.y + 20, '#ffaa00', 12, 2, 25);
                            miniBosses = miniBosses.filter(m => m !== target);
                            showSpeech("CAG√ì EL PERKIN GRANDE WUOM ü¶çüí™üíÄ");
                        }
                    } else {
                        zombies = zombies.filter(z => z !== target);
                        gs.score += 5;
                        gs.kills++;
                        // Zombie death cry when gorilla kills
                        const cry = ZOMBIE_DEATHS[Math.floor(Math.random() * ZOMBIE_DEATHS.length)];
                        addFloat(target.x, target.y, Math.random() > 0.5 ? cry : '+5');
                        addParticles(target.x + 8, target.y + 10, '#ff69b4', 5, 2, 25);
                        // Alternate between insults and piropos
                        const usePiropo = Math.random() > 0.65;
                        showSpeech(usePiropo ? GORILLA_PIROPOS[Math.floor(Math.random() * GORILLA_PIROPOS.length)] : GORILLA_PHRASES[Math.floor(Math.random() * GORILLA_PHRASES.length)]);
                        // Combo tracking for gorilla kills too
                        gs.combo++;
                        gs.comboTimer = 90;
                    }
                    updateUI();
                    checkRoom();
                }
            } else {
                // Patrol near player
                gorilla.x += (player.x - gorilla.x) * 0.02;
                gorilla.y += (player.y - 50 - gorilla.y) * 0.02;
            }

            // Gorilla is permanent - no deactivation timer
        }

        // Spawners
        function spawnZombie() {
            if (gs.over || gs.paused || gs.won) return;

            const dirs = [[0, -30], [0, WORLD.h + 30], [-30, WORLD.h / 2], [WORLD.w + 30, WORLD.h / 2]];
            const [bx, by] = dirs[Math.floor(Math.random() * 4)];
            const x = bx === 0 || bx === WORLD.w + 30 ? bx : 50 + Math.random() * (WORLD.w - 100);
            const y = by === WORLD.h / 2 ? 50 + Math.random() * (WORLD.h - 100) : by;

            zombies.push({ x, y, w: 26, h: 28, speed: 0.4 + Math.random() * 0.3 + gs.room * 0.03, frame: Math.random() * 100 });
        }

        function spawnItem() {
            if (gs.over || gs.paused || gs.won) return;
            items.push({ x: 100 + Math.random() * (WORLD.w - 200), y: 100 + Math.random() * (WORLD.h - 200), w: 24, h: 24 });
        }

        // Fire weapon
        let lastFire = 0;
        function fire() {
            if (gs.over || gs.paused || gs.won) return;

            const now = Date.now();
            const w = WEAPONS[gs.weapon];
            if (now - lastFire < w.fireRate) return;
            lastFire = now;

            // Auto-aim: nudge aim toward nearest zombie
            let aimAngle = player.aim;
            let nearDist = 300;
            const allTargets = boss ? [...zombies, boss] : zombies;
            for (const z of allTargets) {
                const dx = (z.x + z.w / 2) - (player.x + player.w / 2);
                const dy = (z.y + z.h / 2) - (player.y + player.h / 2);
                const d = Math.hypot(dx, dy);
                if (d < nearDist) {
                    const zAngle = Math.atan2(dy, dx);
                    // Only assist if zombie is roughly in aim direction (within 45 deg)
                    let diff = zAngle - player.aim;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    if (Math.abs(diff) < 0.8) {
                        aimAngle = player.aim + diff * 0.4; // 40% correction
                        nearDist = d;
                    }
                }
            }

            for (let i = 0; i < w.pellets; i++) {
                const spread = (Math.random() - 0.5) * w.spread * 2;
                const angle = aimAngle + spread;
                const speed = w.isFlame ? 5 : 9;

                bullets.push({
                    x: player.x + player.w / 2 - 4,
                    y: player.y + player.h / 2 - 4,
                    w: w.isFlame ? 14 : 10,
                    h: w.isFlame ? 14 : 10,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    damage: w.damage,
                    color: w.color,
                    isFlame: w.isFlame,
                    life: w.isFlame ? 40 : 999
                });
            }
        }

        function collide(a, b) {
            return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
        }

        function collideObs(e) {
            for (const o of obstacles) {
                if (o.noCollide) continue;
                // Slightly smaller hitbox than visual for easier navigation
                const shrink = 4;
                const oHit = { x: o.x + shrink, y: o.y + shrink, w: o.w - shrink * 2, h: o.h - shrink * 2 };
                if (collide(e, oHit)) return true;
            }
            return false;
        }

        function showGameOver() {
            gs.over = true;
            checkpoint = gs.room; // Guardar checkpoint en el nivel actual
            gameOverMessage.innerText = GAME_OVER_MSG[Math.floor(Math.random() * GAME_OVER_MSG.length)];
            finalScore.innerText = `Score: ${gs.score} | Habitaci√≥n: ${gs.room}/${MAX_ROOMS} (Contin√∫as aqu√≠)`;
            gameOverScreen.style.display = 'flex';
        }

        function checkRoom() {
            const needBossKill = (gs.room === 4 || gs.room === 7) && boss !== null;
            if (gs.kills >= gs.toKill && !needBossKill) {
                if (gs.room >= MAX_ROOMS) showVictory();
                else nextRoom();
            }
        }

        function nextRoom() {
            gs.room++;
            gs.kills = 0;
            gs.toKill = 20 + gs.room * 3;
            player.x = WORLD.w / 2 - 16;
            player.y = WORLD.h / 2 - 16;
            zombies = [];
            genObstacles();
            updateUI();
            showIntro();
        }

        // Main loop
        function update() {
            if (gs.paused || gs.over || gs.won) { requestAnimationFrame(update); return; }

            gs.pulse++;
            player.frame++;

            // Camera follows player (expandable map)
            const targetCamX = player.x - canvas.width / 2 + player.w / 2;
            const targetCamY = player.y - canvas.height / 2 + player.h / 2;
            camera.x += (targetCamX - camera.x) * 0.1;
            camera.y += (targetCamY - camera.y) * 0.1;

            // Keep camera in bounds
            camera.x = Math.max(0, Math.min(WORLD.w - canvas.width, camera.x));
            camera.y = Math.max(0, Math.min(WORLD.h - canvas.height, camera.y));

            // Background - Dark apocalyptic
            ctx.fillStyle = C.BG;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw RE-style floor tiles
            drawFloor();

            // World border (reinforced walls with detail)
            // Outer wall shadow
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(-camera.x - 12, -camera.y - 12, WORLD.w + 24, 12);
            ctx.fillRect(-camera.x - 12, -camera.y + WORLD.h, WORLD.w + 24, 12);
            ctx.fillRect(-camera.x - 12, -camera.y, 12, WORLD.h);
            ctx.fillRect(-camera.x + WORLD.w, -camera.y, 12, WORLD.h);
            // Metal wall
            const wallGrad = ctx.createLinearGradient(0, 0, 0, 10);
            wallGrad.addColorStop(0, '#4a3a2a');
            wallGrad.addColorStop(0.5, '#2a1a0a');
            wallGrad.addColorStop(1, '#1a0a00');
            ctx.fillStyle = wallGrad;
            ctx.fillRect(-camera.x - 6, -camera.y - 6, WORLD.w + 12, 6);
            ctx.fillRect(-camera.x - 6, -camera.y + WORLD.h, WORLD.w + 12, 6);
            ctx.fillRect(-camera.x - 6, -camera.y, 6, WORLD.h);
            ctx.fillRect(-camera.x + WORLD.w, -camera.y, 6, WORLD.h);
            // Warning stripes on walls
            ctx.strokeStyle = '#6a4a00';
            ctx.lineWidth = 2;
            for (let i = 0; i < WORLD.w; i += 40) {
                const wx = -camera.x + i;
                const wy1 = -camera.y - 4;
                const wy2 = -camera.y + WORLD.h + 1;
                if (wx > -20 && wx < canvas.width + 20) {
                    ctx.beginPath();
                    ctx.moveTo(wx, wy1); ctx.lineTo(wx + 10, wy1 + 5);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(wx, wy2); ctx.lineTo(wx + 10, wy2 + 5);
                    ctx.stroke();
                }
            }
            // Corner bolts
            ctx.fillStyle = '#5a4a3a';
            const corners = [[0,0],[WORLD.w-8,0],[0,WORLD.h-8],[WORLD.w-8,WORLD.h-8]];
            corners.forEach(([cx,cy]) => {
                const sx = cx - camera.x, sy = cy - camera.y;
                ctx.beginPath();
                ctx.arc(sx + 4, sy + 4, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#3a2a1a';
                ctx.beginPath();
                ctx.arc(sx + 4, sy + 4, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#5a4a3a';
            });

            drawObstacles();

            // Player movement with SLIDING collision (no more getting stuck)
            const nx = player.x + player.dx;
            const ny = player.y + player.dy;

            // Try X axis
            const oldX = player.x;
            if (nx >= 0 && nx <= WORLD.w - player.w) player.x = nx;
            if (collideObs(player)) player.x = oldX;

            // Try Y axis independently
            const oldY = player.y;
            if (ny >= 0 && ny <= WORLD.h - player.h) player.y = ny;
            if (collideObs(player)) player.y = oldY;

            // Bullets
            bullets = bullets.filter(b => {
                b.x += b.vx;
                b.y += b.vy;
                if (b.life !== 999) b.life--;

                const bx = b.x - camera.x, by = b.y - camera.y;

                if (b.isFlame) {
                    // Nicer flame with glow
                    ctx.save();
                    ctx.shadowColor = '#ff6600';
                    ctx.shadowBlur = 8;
                    ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 0, ${0.6 + Math.random() * 0.4})`;
                    ctx.beginPath();
                    ctx.arc(bx, by, 5 + Math.random() * 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = `rgba(255, ${200 + Math.random() * 55}, 50, 0.8)`;
                    ctx.beginPath();
                    ctx.arc(bx, by, 2 + Math.random() * 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    // Smoke trail
                    if (Math.random() > 0.5) addParticles(b.x, b.y, 'rgba(80,80,80,0.4)', 1, 0.3, 12);
                } else {
                    // Bullet with glow trail
                    ctx.save();
                    ctx.shadowColor = b.color;
                    ctx.shadowBlur = 6;
                    ctx.fillStyle = b.color;
                    ctx.beginPath();
                    ctx.arc(bx + 3, by + 3, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(bx + 3, by + 3, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

                if (collideObs(b)) return false;
                if (b.life <= 0) return false;

                // Hit zombies
                for (let i = zombies.length - 1; i >= 0; i--) {
                    if (collide(b, zombies[i])) {
                        // üíÄ Zombie death cry
                        const deathMsg = ZOMBIE_DEATHS[Math.floor(Math.random() * ZOMBIE_DEATHS.length)];
                        addFloat(zombies[i].x, zombies[i].y, Math.random() > 0.6 ? deathMsg : '+1');
                        addParticles(zombies[i].x + 8, zombies[i].y + 10, '#44aa44', 8, 2, 25);
                        addParticles(zombies[i].x + 8, zombies[i].y + 10, '#882222', 5, 1.5, 20);

                        // üî• Combo system
                        gs.combo++;
                        gs.comboTimer = 90; // ~1.5 seconds at 60fps
                        if (gs.combo > gs.maxCombo) gs.maxCombo = gs.combo;
                        // Check for combo milestone
                        for (let c = COMBO_MSGS.length - 1; c >= 0; c--) {
                            if (gs.combo === COMBO_MSGS[c].min) {
                                addFloat(player.x, player.y - 30, COMBO_MSGS[c].text);
                                // Combo explosion particles
                                addParticles(player.x + 16, player.y + 16, COMBO_MSGS[c].color, 15, 3, 35);
                                addParticles(player.x + 16, player.y + 16, '#ffff00', 8, 2, 20);
                                break;
                            }
                        }

                        // ‚ù§Ô∏è Heart particles when gorilla active
                        if (gs.goriActive) {
                            addParticles(zombies[i].x + 8, zombies[i].y + 10, '#ff69b4', 4, 1.5, 30);
                        }

                        zombies.splice(i, 1);
                        gs.score++;
                        gs.kills++;
                        updateUI();
                        checkRoom();
                        return false;
                    }
                }

                // Hit boss
                if (boss && collide(b, boss)) {
                    boss.hp -= b.damage;
                    boss.hit = 8;

                    if (boss.hp <= 0) {
                        gs.score += 50;
                        addFloat(boss.x + 40, boss.y, '+50 BOSS!');
                        boss = null;
                        bossHealthEl.style.display = 'none';
                        bossLabel.style.display = 'none';
                        gs.satanic = false;
                        updateUI();
                        checkRoom();
                    }
                    return false;
                }

                // Hit mini-bosses
                for (let i = miniBosses.length - 1; i >= 0; i--) {
                    if (collide(b, miniBosses[i])) {
                        miniBosses[i].hp -= b.damage;
                        miniBosses[i].hit = 8;
                        addFloat(miniBosses[i].x + 20, miniBosses[i].y, `-${b.damage}`);
                        addParticles(miniBosses[i].x + 20, miniBosses[i].y + 20, '#ff6600', 4, 2, 15);

                        if (miniBosses[i].hp <= 0) {
                            gs.score += 25;
                            gs.kills += 3;
                            addFloat(miniBosses[i].x + 20, miniBosses[i].y, '+25 MINI-BOSS! üíÄ');
                            addParticles(miniBosses[i].x + 20, miniBosses[i].y + 20, '#ff0000', 20, 3, 35);
                            addParticles(miniBosses[i].x + 20, miniBosses[i].y + 20, '#ffaa00', 12, 2, 25);
                            const deathCry = ZOMBIE_DEATHS[Math.floor(Math.random() * ZOMBIE_DEATHS.length)];
                            addFloat(miniBosses[i].x + 20, miniBosses[i].y - 20, deathCry);
                            miniBosses.splice(i, 1);
                            updateUI();
                            checkRoom();
                        }
                        return false;
                    }
                }

                return b.x > -50 && b.x < WORLD.w + 50 && b.y > -50 && b.y < WORLD.h + 50;
            });

            // Zombies
            zombies.forEach(z => {
                z.frame++;
                const dx = player.x - z.x, dy = player.y - z.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 0) {
                    const nzx = z.x + (dx / dist) * z.speed;
                    const nzy = z.y + (dy / dist) * z.speed;
                    const test = { x: nzx, y: nzy, w: z.w, h: z.h };
                    if (!collideObs(test)) { z.x = nzx; z.y = nzy; }
                    else { z.x += (dy / dist) * z.speed * 0.5; z.y += (-dx / dist) * z.speed * 0.5; }
                }
                drawZombie(z.x, z.y, z.frame);
                if (collide(z, player)) showGameOver();
            });

            // Boss
            if (boss) {
                if (boss.hit > 0) boss.hit--;
                const dx = player.x - boss.x - 20;
                const dy = player.y - boss.y - 20;
                const dist = Math.hypot(dx, dy);
                if (dist > 60) {
                    boss.x += (dx / dist) * boss.speed;
                    boss.y += (dy / dist) * boss.speed;
                }
                drawBoss(boss);
                if (collide(boss, player)) showGameOver();
            }

            // Items - Star = DEMONIC MODE for gorilla
            items = items.filter(item => {
                drawStar(item.x, item.y, item.w, gs.pulse);
                if (collide(item, player)) {
                    gs.satanic = true;
                    gs.satTimer = 600; // ~10 seconds of rage
                    gorilla.speed = 3.5;
                    showSpeech("üî•üëπ MODO SAT√ÅNICO ACTIVADO CTMRE üëπüî•");
                    addParticles(gorilla.x + 28, gorilla.y + 28, '#ff0000', 20, 3, 30);
                    addParticles(gorilla.x + 28, gorilla.y + 28, '#ff6600', 15, 4, 25);
                    updateUI();
                    return false;
                }
                return true;
            });

            // Mini-bosses
            miniBosses = miniBosses.filter(mb => {
                mb.frame++;
                const dx = player.x - mb.x;
                const dy = player.y - mb.y;
                const dist = Math.hypot(dx, dy);
                mb.x += (dx / dist) * mb.speed;
                mb.y += (dy / dist) * mb.speed;
                drawMiniBoss(mb);
                if (collide(mb, player)) { showGameOver(); return false; }
                return mb.hp > 0;
            });

            updateGorilla();
            updateSpeech();

            drawHelloKitty(player.x, player.y, player.frame, player.aim - Math.PI / 2);

            if (gs.goriActive) drawGorilla(gorilla.x, gorilla.y, gorilla.punch, gorilla.walk);

            drawFloats();
            drawComboHUD();
            updateParticles();

            // ü¶ç‚ù§Ô∏è Gorilla piropo timer - random love phrases (always active now)
            gs.piropoTimer++;
            if (gs.piropoTimer > 0 && gs.piropoTimer % 240 === 0 && Math.random() > 0.5) {
                showSpeech(GORILLA_PIROPOS[Math.floor(Math.random() * GORILLA_PIROPOS.length)]);
            }
            // Heart trail from gorilla (less frequent when not satanic)
            if (Math.random() > (gs.satanic ? 0.7 : 0.92)) {
                addParticles(gorilla.x + 28, gorilla.y - 10, gs.satanic ? '#ff4400' : '#ff69b4', 1, 0.5, 40);
            }

            drawScanlines();

            requestAnimationFrame(update);
        }

        // Controls
        const jc = $('joystickContainer');
        jc.ontouchstart = e => {
            e.preventDefault();
            const r = jc.getBoundingClientRect();
            joystick.active = true;
            joystick.baseX = r.left + r.width / 2;
            joystick.baseY = r.top + r.height / 2;
        };

        jc.ontouchmove = e => {
            e.preventDefault();
            if (!joystick.active) return;
            const t = e.touches[0];
            let dx = t.clientX - joystick.baseX;
            let dy = t.clientY - joystick.baseY;
            const dist = Math.hypot(dx, dy);
            if (dist > joystick.maxDist) { dx = dx / dist * joystick.maxDist; dy = dy / dist * joystick.maxDist; }
            joystickStick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            player.dx = (dx / joystick.maxDist) * player.speed;
            player.dy = (dy / joystick.maxDist) * player.speed;
            if (dist > 5) player.aim = Math.atan2(dy, dx);
        };

        function resetJoy() {
            joystick.active = false;
            joystickStick.style.transform = 'translate(-50%, -50%)';
            player.dx = 0;
            player.dy = 0;
        }
        jc.ontouchend = resetJoy;
        jc.ontouchcancel = resetJoy;

        let fireInt = null;
        const fb = $('fireButton');
        fb.ontouchstart = e => { e.preventDefault(); fire(); fireInt = setInterval(fire, WEAPONS[gs.weapon].fireRate); };
        fb.ontouchend = () => { if (fireInt) { clearInterval(fireInt); fireInt = null; } };
        fb.ontouchcancel = () => { if (fireInt) { clearInterval(fireInt); fireInt = null; } };

        // Keyboard
        const keys = {};
        document.onkeydown = e => {
            keys[e.key] = true;
            if (e.key === ' ') { e.preventDefault(); fire(); }
            updateKeys();

            // üéÆ Konami Code Easter Egg
            if (e.key === KONAMI_CODE[konamiIndex]) {
                konamiIndex++;
                if (konamiIndex === KONAMI_CODE.length) {
                    konamiIndex = 0;
                    triggerKonamiEasterEgg();
                }
            } else {
                konamiIndex = e.key === KONAMI_CODE[0] ? 1 : 0;
            }
        };
        document.onkeyup = e => { keys[e.key] = false; updateKeys(); };

        function updateKeys() {
            player.dx = 0; player.dy = 0;
            if (keys.ArrowLeft || keys.a) { player.dx = -player.speed; player.aim = Math.PI; }
            if (keys.ArrowRight || keys.d) { player.dx = player.speed; player.aim = 0; }
            if (keys.ArrowUp || keys.w) { player.dy = -player.speed; player.aim = -Math.PI / 2; }
            if (keys.ArrowDown || keys.s) { player.dy = player.speed; player.aim = Math.PI / 2; }
            if (player.dx && player.dy) player.aim = Math.atan2(player.dy, player.dx);
            if (keys.q) { gs.weapon = (gs.weapon + 1) % WEAPONS.length; keys.q = false; updateUI(); }
        }

        // Spawners - M√ÅS ZOMBIS!
        setInterval(spawnZombie, 700);
        setInterval(spawnItem, 14000);
        setTimeout(spawnItem, 6000);
        // Mini-boss spawner - every 25 seconds
        setInterval(spawnMiniBoss, 25000);
        setTimeout(spawnMiniBoss, 15000); // First one at 15s

        // üéÆ Konami Code Easter Egg Function
        function triggerKonamiEasterEgg() {
            // Create love overlay
            const overlay = document.createElement('div');
            overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);z-index:9999;display:flex;align-items:center;justify-content:center;flex-direction:column;animation:fadeIn 0.5s ease;cursor:pointer;';
            
            const msg = document.createElement('div');
            msg.innerHTML = `
                <div style="text-align:center;color:#ff69b4;font-family:Courier New;padding:20px;">
                    <div style="font-size:48px;margin-bottom:15px;">ü¶ç‚ù§Ô∏èüéÄ</div>
                    <div style="font-size:22px;font-weight:bold;color:#ff69b4;text-shadow:0 0 20px #ff69b4;margin-bottom:12px;">
                        MENSAJE SECRETO DEL GORIL√ìN
                    </div>
                    <div style="font-size:16px;color:#ffb6c1;line-height:1.8;max-width:350px;margin:auto;">
                        Hay una persona jugando esto<br>
                        que es m√°s hermosa que todas<br>
                        las estrellas del universo ‚≠ê<br><br>
                        <span style="font-size:20px;color:#ff69b4;font-weight:bold;">
                            S√≠, eres t√∫ mi amor üíï
                        </span><br><br>
                        <span style="font-size:14px;color:#dda0dd;">
                            Este juego fue hecho con mucho amor<br>
                            para la persona m√°s especial del mundo üåé
                        </span>
                    </div>
                    <div style="font-size:36px;margin-top:15px;">üíñ‚ú®üíñ</div>
                    <div style="font-size:11px;color:#888;margin-top:10px;">(toca para cerrar)</div>
                </div>
            `;
            overlay.appendChild(msg);
            
            // Floating hearts animation
            for (let i = 0; i < 25; i++) {
                const heart = document.createElement('div');
                heart.innerText = ['üíñ','üíï','üíó','üíù','‚ù§Ô∏è','ü©∑'][Math.floor(Math.random() * 6)];
                heart.style.cssText = `position:absolute;font-size:${16 + Math.random() * 24}px;left:${Math.random() * 100}%;top:${Math.random() * 100}%;animation:float ${3 + Math.random() * 4}s ease-in-out infinite;opacity:${0.4 + Math.random() * 0.6};`;
                overlay.appendChild(heart);
            }
            
            // Add float animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes float { 0%,100% { transform:translateY(0) rotate(0deg); } 50% { transform:translateY(-20px) rotate(10deg); } }
                @keyframes fadeIn { from { opacity:0; } to { opacity:1; } }
            `;
            document.head.appendChild(style);
            
            overlay.onclick = () => { overlay.remove(); style.remove(); };
            document.body.appendChild(overlay);
            
            // Bonus: activate satanic mode!
            if (!gs.satanic && !gs.over && !gs.paused) {
                gs.satanic = true;
                gs.satTimer = 600;
                gorilla.speed = 3.5;
                showSpeech("‚ù§Ô∏è KONAMI CODE = MODO SAT√ÅNICO ‚ù§Ô∏è WUOM");
                addParticles(gorilla.x + 28, gorilla.y + 28, '#ff0000', 20, 3, 30);
                updateUI();
            }
        }

        init();
        requestAnimationFrame(update);
        console.log('%cüéÄ Protocolo Goril√≥n v2.0', 'font-size: 20px; color: #ff69b4; background: #0f380f; padding: 10px;');


    </script>
</body>

</html>