<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ZombiGotchi: Protocolo Goril√≥n v2.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            max-width: 800px;
            max-height: 600px;
            background-color: #9bbc0f;
            border: 8px solid #0f380f;
            border-radius: 12px;
            box-shadow: 0 0 40px rgba(155, 188, 15, 0.3);
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        #ui {
            position: absolute;
            top: 8px;
            left: 12px;
            right: 12px;
            color: #0f380f;
            font-weight: bold;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 10;
        }

        #weaponUI {
            position: absolute;
            top: 30px;
            left: 12px;
            color: #0f380f;
            font-size: 12px;
            z-index: 10;
        }

        #goriStatus.active {
            animation: pulse 0.3s infinite alternate;
        }

        #goriStatus.satanic {
            color: #ff0000 !important;
            text-shadow: 0 0 10px #ff0000;
        }

        @keyframes pulse {
            from {
                opacity: 0.7;
            }

            to {
                opacity: 1;
            }
        }

        #joystickContainer {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 100px;
            height: 100px;
            z-index: 100;
        }

        #joystickBase {
            width: 100px;
            height: 100px;
            background: radial-gradient(circle at 30% 30%, #4a4a4a 0%, #1a1a1a 100%);
            border: 3px solid #0f380f;
            border-radius: 50%;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.5);
        }

        #joystickStick {
            position: absolute;
            width: 45px;
            height: 45px;
            background: radial-gradient(circle at 35% 35%, #666 0%, #1a1a1a 100%);
            border: 2px solid #0f380f;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #fireButton {
            position: absolute;
            bottom: 25px;
            right: 25px;
            width: 80px;
            height: 80px;
            background: radial-gradient(circle at 35% 35%, #8bac0f 0%, #0f380f 100%);
            border: 4px solid #0f380f;
            border-radius: 50%;
            box-shadow: 0 6px 0 #0a2a0a;
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
        }

        #fireButton:active {
            transform: translateY(6px);
            box-shadow: 0 2px 0 #0a2a0a;
        }

        #weaponSwitch {
            position: absolute;
            bottom: 115px;
            right: 30px;
            width: 70px;
            height: 35px;
            background: #306230;
            border: 2px solid #0f380f;
            border-radius: 6px;
            color: #9bbc0f;
            font-weight: bold;
            font-size: 10px;
            z-index: 100;
        }

        #levelIntro,
        #gameOverScreen,
        #victoryScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            text-align: center;
            padding: 20px;
        }

        #levelIntro {
            background: rgba(15, 56, 15, 0.97);
        }

        #gameOverScreen {
            background: rgba(15, 56, 15, 0.95);
        }

        #victoryScreen {
            background: linear-gradient(135deg, #ff6b9d 0%, #ff3366 100%);
            overflow: hidden;
        }

        #levelIntro h2,
        #gameOverScreen h1 {
            color: #9bbc0f;
            font-size: 26px;
            margin-bottom: 15px;
        }

        #poemText {
            color: #8bac0f;
            font-size: 14px;
            line-height: 1.6;
            max-width: 380px;
            margin-bottom: 20px;
            font-style: italic;
        }

        .gameBtn {
            padding: 14px 35px;
            font-size: 16px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            background: #9bbc0f;
            color: #0f380f;
            border: 4px solid #306230;
            border-radius: 10px;
            cursor: pointer;
            box-shadow: 0 5px 0 #306230;
        }

        .gameBtn:active {
            transform: translateY(3px);
            box-shadow: 0 2px 0 #306230;
        }

        #gorillaSpeech {
            position: absolute;
            background: #fff;
            color: #0f380f;
            padding: 6px 10px;
            border-radius: 10px;
            font-size: 11px;
            font-weight: bold;
            max-width: 160px;
            text-align: center;
            display: none;
            z-index: 50;
            pointer-events: none;
        }

        #victoryScreen h1 {
            font-size: 36px;
            color: #fff;
            margin-bottom: 15px;
        }

        #victoryScreen p {
            color: #fff;
            font-size: 18px;
            margin-bottom: 20px;
        }

        .love-explosion {
            position: absolute;
            font-size: 24px;
            animation: floatUp 3s ease-out forwards;
            pointer-events: none;
        }

        @keyframes floatUp {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }

            100% {
                opacity: 0;
                transform: translateY(-350px) scale(1.3);
            }
        }

        .te-quiero {
            position: absolute;
            color: #fff;
            font-weight: bold;
            font-size: 16px;
            text-shadow: 2px 2px 0 #ff1a75;
            animation: teQuieroFloat 3s ease-out forwards;
            pointer-events: none;
        }

        @keyframes teQuieroFloat {
            0% {
                opacity: 1;
                transform: scale(0.5);
            }

            50% {
                opacity: 1;
                transform: scale(1.1);
            }

            100% {
                opacity: 0;
                transform: translateY(-250px) scale(0.7);
            }
        }

        #bossHealth {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 16px;
            background: #0f380f;
            border: 2px solid #fff;
            border-radius: 4px;
            display: none;
            z-index: 20;
        }

        #bossHealthBar {
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6600);
            border-radius: 2px;
            transition: width 0.2s;
        }

        #bossLabel {
            position: absolute;
            top: 34px;
            left: 50%;
            transform: translateX(-50%);
            color: #ff0000;
            font-weight: bold;
            font-size: 12px;
            display: none;
            z-index: 20;
            text-shadow: 1px 1px 0 #000;
        }

        /* Music Button */
        #musicBtn {
            position: absolute;
            top: 8px;
            right: 60px;
            width: 40px;
            height: 40px;
            background: #306230;
            border: 3px solid #0f380f;
            border-radius: 8px;
            font-size: 20px;
            z-index: 100;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #musicBtn.muted {
            opacity: 0.5;
        }
    </style>
</head>

<body>
    <div id="gameContainer">
        <div id="ui">
            <span>SCORE: <span id="scoreDisplay">0</span></span>
            <span id="roomIndicator">1/7</span>
            <span>ü¶ç <span id="goriStatus">OFF</span></span>
        </div>
        <div id="weaponUI">üî´ <span id="weaponName">PISTOLA</span></div>
        <button id="musicBtn" title="Toggle Music">üîä</button>
        <div id="bossLabel">‚ò†Ô∏è ZOMBIE BOSS ‚ò†Ô∏è</div>
        <div id="bossHealth">
            <div id="bossHealthBar" style="width:100%"></div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="gorillaSpeech"></div>
        <div id="joystickContainer">
            <div id="joystickBase">
                <div id="joystickStick"></div>
            </div>
        </div>
        <button id="weaponSwitch">ARMA ‚û°Ô∏è</button>
        <div id="fireButton">üî•</div>
        <div id="levelIntro">
            <h2 id="levelTitle">üè† HABITACI√ìN 1</h2>
            <p id="poemText"></p><button class="gameBtn" id="startLevelBtn">‚ñ∂ COMENZAR</button>
        </div>
        <div id="gameOverScreen">
            <h1>‚ò†Ô∏è GAME OVER ‚ò†Ô∏è</h1>
            <p id="gameOverMessage"></p><button class="gameBtn" id="restartButton">üîÑ REINTENTAR</button>
            <p id="finalScore"></p>
        </div>
        <div id="victoryScreen">
            <div id="victoryContent">
                <h1>üèÜ ¬°GANASTE! üèÜ</h1>
                <p>¬°Completaste las 7 habitaciones!</p>
                <p id="victoryScore"></p><button class="gameBtn" id="playAgainBtn">üíï JUGAR DE NUEVO</button>
            </div>
        </div>
    </div>


    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('gameContainer');
        const MAX_ROOMS = 7;

        // === FIX CANVAS RESOLUTION ===
        function resizeCanvas() {
            const rect = container.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // UI Elements
        const $ = id => document.getElementById(id);

        // === MUSIC SYSTEM (YouTube IFrame API - Most Reliable) ===
        const musicBtn = $('musicBtn');
        let musicPlaying = false;
        let ytPlayer = null;
        let ytReady = false;

        // Load YouTube IFrame API
        const ytScript = document.createElement('script');
        ytScript.src = 'https://www.youtube.com/iframe_api';
        document.head.appendChild(ytScript);

        // YouTube API calls this automatically when ready
        window.onYouTubeIframeAPIReady = function () {
            // Create hidden container for YT player
            const ytDiv = document.createElement('div');
            ytDiv.id = 'ytplayer';
            ytDiv.style.cssText = 'position:absolute;width:1px;height:1px;overflow:hidden;opacity:0;pointer-events:none;';
            document.body.appendChild(ytDiv);

            ytPlayer = new YT.Player('ytplayer', {
                height: '1',
                width: '1',
                videoId: 'cE6wxDqdOV0', // Lana Del Rey - Video Games
                playerVars: {
                    autoplay: 0,
                    loop: 1,
                    playlist: 'cE6wxDqdOV0', // needed for loop
                    controls: 0,
                    disablekb: 1,
                    fs: 0,
                    modestbranding: 1,
                    rel: 0
                },
                events: {
                    onReady: function () {
                        ytReady = true;
                        ytPlayer.setVolume(50);
                        console.log('üéµ YouTube player ready');
                    },
                    onStateChange: function (e) {
                        // If video ends, replay (backup for loop)
                        if (e.data === YT.PlayerState.ENDED) {
                            ytPlayer.playVideo();
                        }
                    }
                }
            });
        };

        function tryPlayMusic() {
            if (ytReady && ytPlayer && !musicPlaying) {
                ytPlayer.playVideo();
                musicPlaying = true;
                musicBtn.textContent = 'üéµ';
                musicBtn.classList.remove('muted');
            }
        }

        function toggleMusic() {
            if (!ytReady || !ytPlayer) return;
            if (musicPlaying) {
                ytPlayer.pauseVideo();
                musicBtn.textContent = 'üîá';
                musicBtn.classList.add('muted');
            } else {
                ytPlayer.playVideo();
                musicBtn.textContent = 'üéµ';
                musicBtn.classList.remove('muted');
            }
            musicPlaying = !musicPlaying;
        }

        musicBtn.onclick = toggleMusic;
        musicBtn.ontouchend = (e) => { e.preventDefault(); toggleMusic(); };
        const scoreDisplay = $('scoreDisplay');
        const goriStatusEl = $('goriStatus');
        const roomIndicator = $('roomIndicator');
        const weaponName = $('weaponName');
        const gameOverScreen = $('gameOverScreen');
        const gameOverMessage = $('gameOverMessage');
        const finalScore = $('finalScore');
        const levelIntro = $('levelIntro');
        const levelTitle = $('levelTitle');
        const poemText = $('poemText');
        const victoryScreen = $('victoryScreen');
        const victoryScore = $('victoryScore');
        const joystickStick = $('joystickStick');
        const gorillaSpeech = $('gorillaSpeech');
        const bossHealthEl = $('bossHealth');
        const bossHealthBar = $('bossHealthBar');
        const bossLabel = $('bossLabel');

        // Colors
        const C = { DARK: '#0f380f', MID: '#306230', LIGHT: '#8bac0f', BG: '#1a1a1a', FLOOR: '#252525', PINK: '#ffb6c1', HOTPINK: '#ff69b4 ' };

        // Weapons
        const WEAPONS = [
            { name: 'PISTOLA', emoji: 'üî´', fireRate: 150, spread: 0, pellets: 1, damage: 1, color: C.DARK },
            { name: 'ESCOPETA', emoji: 'üí•', fireRate: 400, spread: 0.35, pellets: 7, damage: 1, color: '#8b4513' },
            { name: 'MINIGUN', emoji: 'üî•', fireRate: 60, spread: 0.12, pellets: 1, damage: 1, color: '#ff4500' },
            { name: 'LANZALLAMAS', emoji: 'üî•', fireRate: 40, spread: 0.45, pellets: 4, damage: 0.5, color: '#ff6600', isFlame: true }
        ];

        // Poems
        const POEMS = [
            "üéÄ Hello Kitty entra al campo de batalla,\nCon su lazo rosa y valor sin igual.\n¬°Los zombis tiemblan ante tanta maravilla!",
            "üåô Segunda morada, el peligro crece,\nPero Hello Kitty nunca retrocede.\n¬°Adelante, guerrera de rosa y blanco!",
            "‚öîÔ∏è Tres victorias, tres lazos de honor,\nEl Goril√≥n ruge con fervor.\n¬°Nadie detiene a esta dupla ganadora!",
            "üî• Cuatro batallas, el fuego arde,\nHello Kitty no conoce lo cobarde.\n¬°Los zombis huyen de su mirada!",
            "ü¶ç El Goril√≥n susurra con amor:\n\"¬°Esta gatita es mi se√±ora!\"\n¬°Juntos son invencibles!",
            "üí´ Casi llegas al final glorioso,\nEl camino ha sido victorioso.\n¬°Una habitaci√≥n m√°s, campeona!",
            "üëë LA BATALLA FINAL TE ESPERA\nEl Boss Zombi quiere pelea,\nPero Hello Kitty es la verdadera\n¬°REINA DEL APOCALIPSIS!"
        ];

        const GORILLA_PHRASES = ["SALE PAJAR√ìN CULIAO FEO ü¶ç", "PERRO IJO LA PERRA üêï", "SAPO CTMRE üê∏", "ROBO M√ÅS QUE USTEDES WEON", "YOJOI CHORO WUOM üò§", "√âNFASISSS üí™üî•", "CON MI SE√ëORA NO PAJAR√ìN CULIAO ü¶ç‚ù§Ô∏è", "AL√âJATE DE MI KUROMI CULIAO üíÄ", "CARTERA DE MIMBRE Y LA CTMRE KSAKJSKJ üß∫", "ANDA PA LA CASA PERKIN QL üè†", "TERRIBLE DE SACOWEA ESTE ZOMBI üíÄ", "SOY M√ÅS CHORO QUE TODOS USTEDES üòé", "PURO PERKIN MUERTO AQU√ç WUOM ü™¶", "CACH√ÅI O NO CACH√ÅI CTMRE üß†"];
        const GAME_OVER_MSG = ["CAGASTE WUOM üíÄ", "El Goril√≥n se fue pal hoyo ü¶çüíî", "Los zombis te sacaron la chucha üéâ", "¬°Vuelve m√°s choro! üí™", "TERRIBLE DE MALO WUON üò≠"];

        // World size (expandable map)
        const WORLD = { w: 1200, h: 900 };

        // State
        let gs = {};
        let player = {};
        let camera = { x: 0, y: 0 };
        let bullets = [];
        let zombies = [];
        let items = [];
        let obstacles = [];
        let gorilla = {};
        let boss = null;
        let joystick = { active: false, baseX: 0, baseY: 0, maxDist: 40 };
        let loveInterval = null;
        let checkpoint = 1; // Guardar el nivel actual como checkpoint

        function init() {
            if (loveInterval) clearInterval(loveInterval);
            document.querySelectorAll('.love-explosion,.te-quiero').forEach(e => e.remove());

            gs = { score: 0, room: checkpoint, kills: 0, toKill: 12 + checkpoint * 2, over: false, won: false, paused: true, goriActive: false, goriTimer: 0, goriSpeechTimer: 0, pulse: 0, floats: [], weapon: 0, satanic: false };
            player = { x: WORLD.w / 2 - 16, y: WORLD.h / 2 - 16, w: 32, h: 32, speed: 2.5, dx: 0, dy: 0, frame: 0, aim: 0 };
            gorilla = { x: -200, y: -200, w: 56, h: 56, speed: 3, target: null, punch: 0, walk: 0 };
            boss = null;
            bullets = []; zombies = []; items = []; particles = [];
            genObstacles();
            updateUI();
            gameOverScreen.style.display = 'none';
            victoryScreen.style.display = 'none';
            bossHealthEl.style.display = 'none';
            bossLabel.style.display = 'none';
            showIntro();
        }

        function showIntro() {
            gs.paused = true;
            levelTitle.innerText = `üè† HABITACI√ìN ${gs.room}/${MAX_ROOMS}`;
            poemText.innerText = POEMS[gs.room - 1];
            levelIntro.style.display = 'flex';
        }

        function startLevel() {
            levelIntro.style.display = 'none';
            gs.paused = false;

            // FORCE MUSIC START DIRECTLY
            tryPlayMusic();

            // Spawn boss on room 4 and 7
            if (gs.room === 4 || gs.room === 7) {
                spawnBoss();
            }
        }

        function spawnBoss() {
            boss = {
                x: WORLD.w / 2 - 40,
                y: 100,
                w: 80, h: 80,
                hp: 50 + gs.room * 10,
                maxHp: 50 + gs.room * 10,
                speed: 1.2,
                frame: 0,
                hit: 0
            };
            bossHealthEl.style.display = 'block';
            bossLabel.style.display = 'block';
        }

        $('startLevelBtn').onclick = startLevel;
        $('startLevelBtn').ontouchend = e => { e.preventDefault(); startLevel(); };

        function showVictory() {
            gs.won = true;
            gs.paused = true;
            victoryScore.innerText = `Puntuaci√≥n: ${gs.score} üåü`;
            victoryScreen.style.display = 'flex';
            startLoveExplosion();
        }

        function startLoveExplosion() {
            const hearts = ['‚ù§Ô∏è', 'üíï', 'üíñ', 'üíó', 'ü¶ç', '‚ú®', 'üéÄ', 'üåü'];
            const texts = ['TE QUIERO', 'TE AMO', 'CONY ‚ù§Ô∏è', 'ERES LA MEJOR', 'GANASTE', 'ü¶çüíï', 'CAMPEONA', 'HELLO KITTY'];
            let count = 0;

            function create() {
                if (count++ > 80) { clearInterval(loveInterval); return; }
                const h = document.createElement('div');
                h.className = 'love-explosion';
                h.innerText = hearts[Math.floor(Math.random() * hearts.length)];
                h.style.left = Math.random() * 100 + '%';
                h.style.top = (75 + Math.random() * 25) + '%';
                h.style.fontSize = (18 + Math.random() * 25) + 'px';
                victoryScreen.appendChild(h);
                setTimeout(() => h.remove(), 3500);

                if (Math.random() > 0.4) {
                    const t = document.createElement('div');
                    t.className = 'te-quiero';
                    t.innerText = texts[Math.floor(Math.random() * texts.length)];
                    t.style.left = (10 + Math.random() * 80) + '%';
                    t.style.top = (70 + Math.random() * 30) + '%';
                    victoryScreen.appendChild(t);
                    setTimeout(() => t.remove(), 3500);
                }
            }
            for (let i = 0; i < 15; i++) setTimeout(create, i * 40);
            loveInterval = setInterval(create, 90);
        }

        $('playAgainBtn').onclick = init;
        $('restartButton').onclick = init;

        function genObstacles() {
            obstacles = [];
            const n = 6 + gs.room;
            const types = ['ruin', 'tree', 'tomb', 'car', 'blood', 'barrel'];

            for (let i = 0; i < n; i++) {
                let x, y, ok = false, att = 0;
                while (!ok && att++ < 40) {
                    x = 80 + Math.random() * (WORLD.w - 200);
                    y = 80 + Math.random() * (WORLD.h - 200);
                    const d = Math.hypot(x - WORLD.w / 2, y - WORLD.h / 2);
                    if (d > 120) ok = true;
                }
                if (ok) {
                    const type = types[Math.floor(Math.random() * types.length)];
                    let w = 50, h = 50;
                    if (type === 'ruin') { w = 60 + Math.random() * 50; h = 50 + Math.random() * 40; }
                    else if (type === 'tree') { w = 30; h = 60; }
                    else if (type === 'tomb') { w = 35; h = 45; }
                    else if (type === 'car') { w = 70; h = 35; }
                    else if (type === 'blood') { w = 40; h = 40; }
                    else if (type === 'barrel') { w = 25; h = 30; }
                    obstacles.push({ x, y, w, h, type });
                }
            }
            // Add some decorative blood pools (non-blocking)
            for (let i = 0; i < 8; i++) {
                const x = 50 + Math.random() * (WORLD.w - 100);
                const y = 50 + Math.random() * (WORLD.h - 100);
                obstacles.push({ x, y, w: 30, h: 20, type: 'decor_blood', noCollide: true });
            }
        }

        function updateUI() {
            scoreDisplay.innerText = gs.score;
            roomIndicator.innerText = `${gs.room}/${MAX_ROOMS}`;
            const w = WEAPONS[gs.weapon];
            weaponName.innerText = `${w.emoji} ${w.name}`;
            goriStatusEl.innerText = gs.goriActive ? (gs.satanic ? '¬°SAT√ÅNICO!' : 'ACTIVO!') : 'OFF';
            goriStatusEl.classList.toggle('active', gs.goriActive);
            goriStatusEl.classList.toggle('satanic', gs.satanic);
        }

        // Switch weapon
        $('weaponSwitch').onclick = () => { gs.weapon = (gs.weapon + 1) % WEAPONS.length; updateUI(); };
        $('weaponSwitch').ontouchend = e => { e.preventDefault(); gs.weapon = (gs.weapon + 1) % WEAPONS.length; updateUI(); };

        // === PARTICLE SYSTEM ===
        let particles = [];
        function addParticles(x, y, color, count, speed, life) {
            for (let i = 0; i < count; i++) {
                const angle = Math.random() * Math.PI * 2;
                const spd = (0.5 + Math.random()) * speed;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * spd,
                    vy: Math.sin(angle) * spd,
                    life: life || 30,
                    maxLife: life || 30,
                    color,
                    size: 2 + Math.random() * 3
                });
            }
        }
        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.96;
                p.vy *= 0.96;
                p.life--;
                if (p.life <= 0) return false;
                const sx = p.x - camera.x, sy = p.y - camera.y;
                const alpha = p.life / p.maxLife;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(sx, sy, p.size * alpha, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
                return true;
            });
        }

        // === DRAW HELLO KITTY (IMPROVED) ===
        function drawHelloKitty(sx, sy, frame, angle) {
            const x = sx - camera.x, y = sy - camera.y;
            ctx.save();
            ctx.translate(x + 16, y + 16);

            // Soft glow under character
            ctx.shadowColor = '#ff69b4';
            ctx.shadowBlur = 12;
            ctx.fillStyle = 'rgba(255, 105, 180, 0.15)';
            ctx.beginPath();
            ctx.ellipse(0, 20, 18, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            ctx.rotate(angle);

            // Legs (animated walk)
            const legAnim = Math.sin(frame * 0.2) * 3;
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(-4, 24 + legAnim, 4, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(4, 24 - legAnim, 4, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 0.5;
            ctx.stroke();

            // Body (pink dress)
            ctx.fillStyle = '#ffb6c1';
            ctx.beginPath();
            ctx.moveTo(-10, 12);
            ctx.quadraticCurveTo(-12, 22, -8, 24);
            ctx.lineTo(8, 24);
            ctx.quadraticCurveTo(12, 22, 10, 12);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#e0909e';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Body stripe
            ctx.fillStyle = '#ff99aa';
            ctx.fillRect(-2, 14, 4, 8);

            // Arms
            const armAnim = Math.sin(frame * 0.15) * 2;
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(-13, 14 + armAnim, 4, 6, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(13, 14 - armAnim, 4, 6, 0.3, 0, Math.PI * 2);
            ctx.fill();

            // Face (white circle with soft edge)
            const faceGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 14);
            faceGrad.addColorStop(0, '#ffffff');
            faceGrad.addColorStop(1, '#f0f0f0');
            ctx.fillStyle = faceGrad;
            ctx.beginPath();
            ctx.ellipse(0, 0, 14, 12, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Ears
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#ccc';
            ctx.beginPath();
            ctx.moveTo(-10, -8);
            ctx.lineTo(-14, -18);
            ctx.lineTo(-4, -12);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Inner ear pink
            ctx.fillStyle = '#ffccdd';
            ctx.beginPath();
            ctx.moveTo(-9, -9);
            ctx.lineTo(-12, -16);
            ctx.lineTo(-5, -12);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(10, -8);
            ctx.lineTo(14, -18);
            ctx.lineTo(4, -12);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#ccc';
            ctx.stroke();
            ctx.fillStyle = '#ffccdd';
            ctx.beginPath();
            ctx.moveTo(9, -9);
            ctx.lineTo(12, -16);
            ctx.lineTo(5, -12);
            ctx.closePath();
            ctx.fill();

            // Bow (pink - bigger, nicer)
            ctx.fillStyle = '#ff69b4';
            ctx.beginPath();
            ctx.ellipse(-13, -14, 7, 5, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(-5, -16, 6, 4, 0.3, 0, Math.PI * 2);
            ctx.fill();
            // Bow highlight
            ctx.fillStyle = '#ff8dc7';
            ctx.beginPath();
            ctx.ellipse(-13, -15, 3, 2, -0.3, 0, Math.PI * 2);
            ctx.fill();
            // Bow center
            ctx.fillStyle = '#ff1493';
            ctx.beginPath();
            ctx.arc(-9, -15, 2.5, 0, Math.PI * 2);
            ctx.fill();

            // Eyes (with shine)
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(-5, -2, 2.2, 3.2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(5, -2, 2.2, 3.2, 0, 0, Math.PI * 2);
            ctx.fill();
            // Eye shine
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-4, -3, 1, 0, Math.PI * 2);
            ctx.arc(6, -3, 1, 0, Math.PI * 2);
            ctx.fill();

            // Nose
            ctx.fillStyle = '#ffcc00';
            ctx.beginPath();
            ctx.ellipse(0, 3, 2.5, 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#ffdd44';
            ctx.beginPath();
            ctx.ellipse(-0.5, 2.5, 1, 1, 0, 0, Math.PI * 2);
            ctx.fill();

            // Whiskers (smoother)
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 0.8;
            ctx.beginPath();
            ctx.moveTo(-16, -1); ctx.lineTo(-6, 1);
            ctx.moveTo(-16, 3); ctx.lineTo(-6, 3);
            ctx.moveTo(-16, 7); ctx.lineTo(-6, 5);
            ctx.moveTo(16, -1); ctx.lineTo(6, 1);
            ctx.moveTo(16, 3); ctx.lineTo(6, 3);
            ctx.moveTo(16, 7); ctx.lineTo(6, 5);
            ctx.stroke();

            // Weapon in hand
            ctx.fillStyle = WEAPONS[gs.weapon].color;
            ctx.save();
            ctx.translate(14, 12);
            ctx.rotate(0.3);
            ctx.fillRect(0, -2, 10, 4);
            ctx.fillStyle = '#333';
            ctx.fillRect(8, -3, 4, 6);
            ctx.restore();

            ctx.restore();
        }

        // === DRAW GORILLA (Satanic mode - IMPROVED) ===
        function drawGorilla(sx, sy, punch, walk) {
            const x = sx - camera.x, y = sy - camera.y;
            const p = punch > 0;
            const shake = p ? Math.sin(punch * 3) * 5 : 0;
            const bounce = Math.sin(walk * 0.15) * 2;

            ctx.save();
            ctx.translate(x + 28, y + 28);

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.35)';
            ctx.beginPath();
            ctx.ellipse(0, 38, 28, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.fillStyle = gs.satanic ? '#150000' : '#221508';
            ctx.beginPath();
            ctx.ellipse(-10 + shake, 30 + bounce, 8, 10, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(10 + shake, 30 + bounce, 8, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Body with gradient
            const bodyGrad = ctx.createRadialGradient(shake, 8 + bounce, 5, shake, 10 + bounce, 26);
            bodyGrad.addColorStop(0, gs.satanic ? '#2a0505' : '#3a2a14');
            bodyGrad.addColorStop(1, gs.satanic ? '#0a0000' : '#1a0e04');
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.ellipse(shake, 10 + bounce, 24, 22, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = gs.satanic ? '#0a0000' : '#120a02';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Chest patch
            ctx.fillStyle = gs.satanic ? '#3a1010' : '#4a3a2a';
            ctx.beginPath();
            ctx.ellipse(shake, 6 + bounce, 12, 14, 0, 0, Math.PI * 2);
            ctx.fill();

            // Fur texture
            ctx.strokeStyle = gs.satanic ? '#200505' : '#2a1a0a';
            ctx.lineWidth = 0.8;
            for (let i = 0; i < 8; i++) {
                const fx = shake + (Math.random() - 0.5) * 40;
                const fy = bounce + (Math.random() - 0.5) * 35;
                ctx.beginPath();
                ctx.moveTo(fx, fy);
                ctx.lineTo(fx + (Math.random() - 0.5) * 6, fy + 4);
                ctx.stroke();
            }

            // Head with gradient
            const headGrad = ctx.createRadialGradient(shake, -16 + bounce, 3, shake, -14 + bounce, 18);
            headGrad.addColorStop(0, gs.satanic ? '#2a0505' : '#3a2a14');
            headGrad.addColorStop(1, gs.satanic ? '#0a0000' : '#1a0e04');
            ctx.fillStyle = headGrad;
            ctx.beginPath();
            ctx.ellipse(shake, -14 + bounce, 16, 14, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = gs.satanic ? '#0a0000' : '#120a02';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Brow ridge
            ctx.fillStyle = gs.satanic ? '#1a0000' : '#2a1a0a';
            ctx.beginPath();
            ctx.ellipse(shake, -20 + bounce, 14, 4, 0, 0, Math.PI);
            ctx.fill();

            // Face
            ctx.fillStyle = gs.satanic ? '#4a2020' : '#7a6a5a';
            ctx.beginPath();
            ctx.ellipse(shake, -10 + bounce, 10, 8, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nostrils
            ctx.fillStyle = gs.satanic ? '#2a0a0a' : '#3a2a1a';
            ctx.beginPath();
            ctx.ellipse(-3 + shake, -7 + bounce, 2, 1.5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(3 + shake, -7 + bounce, 2, 1.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // SATANIC EYES
            if (gs.satanic) {
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 20;
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(-6 + shake, -15 + bounce, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(6 + shake, -15 + bounce, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
                // Slit pupils
                ctx.fillStyle = '#440000';
                ctx.fillRect(-6.5 + shake, -18 + bounce, 1, 6);
                ctx.fillRect(5.5 + shake, -18 + bounce, 1, 6);

                // Horns (curved)
                const hornGrad = ctx.createLinearGradient(0, -22 + bounce, 0, -40 + bounce);
                hornGrad.addColorStop(0, '#660000');
                hornGrad.addColorStop(1, '#ff2200');
                ctx.fillStyle = hornGrad;
                ctx.beginPath();
                ctx.moveTo(-14 + shake, -22 + bounce);
                ctx.quadraticCurveTo(-12 + shake, -32 + bounce, -6 + shake, -38 + bounce);
                ctx.quadraticCurveTo(-8 + shake, -30 + bounce, -4 + shake, -22 + bounce);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(14 + shake, -22 + bounce);
                ctx.quadraticCurveTo(12 + shake, -32 + bounce, 6 + shake, -38 + bounce);
                ctx.quadraticCurveTo(8 + shake, -30 + bounce, 4 + shake, -22 + bounce);
                ctx.fill();
            } else {
                ctx.fillStyle = p ? '#ff3333' : '#fff';
                ctx.beginPath();
                ctx.arc(-6 + shake, -15 + bounce, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(6 + shake, -15 + bounce, 3, 0, Math.PI * 2);
                ctx.fill();
                // Pupils
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-6 + shake, -15 + bounce, 1.5, 0, Math.PI * 2);
                ctx.arc(6 + shake, -15 + bounce, 1.5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Mouth when punching
            if (p) {
                ctx.fillStyle = gs.satanic ? '#aa0000' : '#330000';
                ctx.beginPath();
                ctx.ellipse(shake, -3 + bounce, 7, 6, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(-5 + shake, -5 + bounce);
                ctx.lineTo(-3 + shake, -2 + bounce);
                ctx.lineTo(-1 + shake, -5 + bounce);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(1 + shake, -5 + bounce);
                ctx.lineTo(3 + shake, -2 + bounce);
                ctx.lineTo(5 + shake, -5 + bounce);
                ctx.fill();
            }

            // Arms (muscular with fists)
            const armExt = p ? 20 : 0;
            const armY = p ? -8 : 6;
            ctx.fillStyle = gs.satanic ? '#1a0000' : '#2a1a0a';
            ctx.beginPath();
            ctx.ellipse(-26 - armExt + shake, armY + bounce, 12, 9, -0.2, 0, Math.PI * 2);
            ctx.fill();
            const fistGrad = ctx.createRadialGradient(-36 - armExt + shake, armY + bounce, 1, -36 - armExt + shake, armY + bounce, 8);
            fistGrad.addColorStop(0, gs.satanic ? '#2a0505' : '#3a2a14');
            fistGrad.addColorStop(1, gs.satanic ? '#0a0000' : '#1a0e04');
            ctx.fillStyle = fistGrad;
            ctx.beginPath();
            ctx.arc(-36 - armExt + shake, armY + bounce, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = gs.satanic ? '#1a0000' : '#2a1a0a';
            ctx.beginPath();
            ctx.ellipse(26 + armExt + shake, armY + bounce, 12, 9, 0.2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = fistGrad;
            ctx.beginPath();
            ctx.arc(36 + armExt + shake, armY + bounce, 8, 0, Math.PI * 2);
            ctx.fill();

            // Impact lines when punching
            if (p) {
                ctx.strokeStyle = gs.satanic ? '#ff4400' : '#ffcc00';
                ctx.lineWidth = 2;
                const impX = 44 + shake;
                for (let i = 0; i < 4; i++) {
                    const a = (Math.PI / 3) * i - Math.PI / 3;
                    ctx.beginPath();
                    ctx.moveTo(impX + Math.cos(a) * 8, armY + bounce + Math.sin(a) * 8);
                    ctx.lineTo(impX + Math.cos(a) * 14, armY + bounce + Math.sin(a) * 14);
                    ctx.stroke();
                }
            }

            // Fire aura when satanic
            if (gs.satanic) {
                for (let i = 0; i < 3; i++) {
                    if (Math.random() > 0.4) {
                        addParticles(
                            sx + 28 + shake + (Math.random() - 0.5) * 50,
                            sy + 28 + bounce + (Math.random() - 0.5) * 50,
                            `rgb(255, ${Math.floor(Math.random() * 100)}, 0)`,
                            1, 1, 15
                        );
                    }
                }
            }

            ctx.restore();
        }

        // === DRAW ZOMBIE (IMPROVED - BIGGER) ===
        function drawZombie(sx, sy, frame) {
            const x = sx - camera.x, y = sy - camera.y;
            const wobble = Math.sin(frame * 0.15) * 3;
            const breathe = Math.sin(frame * 0.08) * 0.5;
            const cx = 13; // center x offset

            ctx.save();

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.beginPath();
            ctx.ellipse(x + cx, y + 30, 12, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            const legMove = Math.sin(frame * 0.12) * 3;
            ctx.fillStyle = '#1a3a1a';
            ctx.fillRect(x + 6, y + 23, 5, 7 + legMove);
            ctx.fillRect(x + 15, y + 23, 5, 7 - legMove);

            // Body (torn clothes)
            ctx.fillStyle = '#2a4a2a';
            ctx.beginPath();
            ctx.ellipse(x + cx, y + 19 + breathe, 9, 7, 0, 0, Math.PI * 2);
            ctx.fill();
            // Torn cloth detail
            ctx.fillStyle = '#3a5a3a';
            ctx.fillRect(x + 4, y + 16, 4, 6);
            ctx.fillRect(x + 17, y + 17, 3, 5);

            // Arms (reaching out)
            const arm = Math.sin(frame * 0.1) * 5;
            ctx.fillStyle = '#306230';
            ctx.save();
            ctx.translate(x + 3 + arm, y + 16);
            ctx.rotate(-0.4 + Math.sin(frame * 0.08) * 0.2);
            ctx.fillRect(-2, 0, 4, 11);
            ctx.fillRect(-3, 10, 3, 3);
            ctx.fillRect(1, 10, 3, 3);
            ctx.restore();
            ctx.save();
            ctx.translate(x + 22 - arm, y + 16);
            ctx.rotate(0.4 - Math.sin(frame * 0.08) * 0.2);
            ctx.fillRect(-2, 0, 4, 11);
            ctx.fillRect(-3, 10, 3, 3);
            ctx.fillRect(1, 10, 3, 3);
            ctx.restore();

            // Head
            const headGrad = ctx.createRadialGradient(x + cx + wobble, y + 8, 1, x + cx + wobble, y + 8, 11);
            headGrad.addColorStop(0, '#3a6a3a');
            headGrad.addColorStop(1, '#1a3a1a');
            ctx.fillStyle = headGrad;
            ctx.beginPath();
            ctx.arc(x + cx + wobble, y + 8, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#0a2a0a';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Eyes (glowing)
            ctx.shadowColor = '#aaff00';
            ctx.shadowBlur = 5;
            ctx.fillStyle = '#ccff00';
            ctx.beginPath();
            ctx.arc(x + 9 + wobble, y + 6, 2.5, 0, Math.PI * 2);
            ctx.arc(x + 17 + wobble, y + 6, 2.5, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            // Pupils
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(x + 9 + wobble, y + 6, 1.2, 0, Math.PI * 2);
            ctx.arc(x + 17 + wobble, y + 6, 1.2, 0, Math.PI * 2);
            ctx.fill();

            // Mouth (drooling)
            ctx.fillStyle = '#0a1a0a';
            ctx.beginPath();
            ctx.ellipse(x + cx + wobble, y + 13, 4, 3, 0, 0, Math.PI);
            ctx.fill();
            // Drool
            ctx.fillStyle = 'rgba(100, 200, 80, 0.6)';
            ctx.fillRect(x + 12 + wobble, y + 14, 3, 4 + Math.sin(frame * 0.1) * 2);

            // Wound marks
            ctx.strokeStyle = '#4a0a0a';
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.moveTo(x + 5 + wobble, y + 3);
            ctx.lineTo(x + 9 + wobble, y + 7);
            ctx.stroke();

            ctx.restore();
        }

        // === DRAW BOSS (IMPROVED) ===
        function drawBoss(b) {
            const x = b.x - camera.x, y = b.y - camera.y;
            const shake = b.hit > 0 ? Math.sin(b.hit * 5) * 5 : 0;
            b.frame++;
            const breathe = Math.sin(b.frame * 0.04) * 3;

            ctx.save();

            // Dark aura
            ctx.shadowColor = '#00ff00';
            ctx.shadowBlur = 20 + Math.sin(b.frame * 0.05) * 10;
            ctx.fillStyle = 'rgba(0, 80, 0, 0.15)';
            ctx.beginPath();
            ctx.arc(x + 40 + shake, y + 40, 55, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;

            // Shadow
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.beginPath();
            ctx.ellipse(x + 40, y + 92, 40, 10, 0, 0, Math.PI * 2);
            ctx.fill();

            // Legs
            ctx.fillStyle = '#0f2a0f';
            ctx.fillRect(x + 22 + shake, y + 78 + breathe, 14, 14);
            ctx.fillRect(x + 44 + shake, y + 78 + breathe, 14, 14);

            // Big zombie body with gradient
            const bodyGrad = ctx.createRadialGradient(x + 40 + shake, y + 45, 5, x + 40 + shake, y + 50, 40);
            bodyGrad.addColorStop(0, '#2a5a2a');
            bodyGrad.addColorStop(1, '#0a1f0a');
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.ellipse(x + 40 + shake, y + 50 + breathe, 35, 38, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#061506';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Spikes on shoulders
            ctx.fillStyle = '#1a3a1a';
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(x + 8 + i * 6 + shake, y + 25 + breathe);
                ctx.lineTo(x + 11 + i * 6 + shake, y + 12 + breathe);
                ctx.lineTo(x + 14 + i * 6 + shake, y + 25 + breathe);
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(x + 54 + i * 6 + shake, y + 25 + breathe);
                ctx.lineTo(x + 57 + i * 6 + shake, y + 12 + breathe);
                ctx.lineTo(x + 60 + i * 6 + shake, y + 25 + breathe);
                ctx.fill();
            }

            // Ribs detail
            ctx.strokeStyle = '#0a2a0a';
            ctx.lineWidth = 1.5;
            for (let i = 0; i < 4; i++) {
                ctx.beginPath();
                ctx.moveTo(x + 28 + shake, y + 38 + i * 7 + breathe);
                ctx.quadraticCurveTo(x + 40 + shake, y + 35 + i * 7 + breathe, x + 52 + shake, y + 38 + i * 7 + breathe);
                ctx.stroke();
            }

            // Head with gradient
            const headGrad = ctx.createRadialGradient(x + 40 + shake, y + 12, 3, x + 40 + shake, y + 15, 27);
            headGrad.addColorStop(0, '#2a5a2a');
            headGrad.addColorStop(1, '#0a1f0a');
            ctx.fillStyle = headGrad;
            ctx.beginPath();
            ctx.arc(x + 40 + shake, y + 15, 25, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#061506';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Scars
            ctx.strokeStyle = '#4a1a1a';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x + 25 + shake, y + 5);
            ctx.lineTo(x + 30 + shake, y + 18);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x + 55 + shake, y + 8);
            ctx.lineTo(x + 48 + shake, y + 20);
            ctx.stroke();

            // Glowing eyes
            ctx.shadowColor = '#ff0000';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(x + 30 + shake, y + 10, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + 50 + shake, y + 10, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#660000';
            ctx.beginPath();
            ctx.arc(x + 30 + shake, y + 10, 2, 0, Math.PI * 2);
            ctx.arc(x + 50 + shake, y + 10, 2, 0, Math.PI * 2);
            ctx.fill();

            // Mouth with teeth
            ctx.fillStyle = '#0a0a0a';
            ctx.beginPath();
            ctx.moveTo(x + 25 + shake, y + 25);
            ctx.quadraticCurveTo(x + 40 + shake, y + 40, x + 55 + shake, y + 25);
            ctx.closePath();
            ctx.fill();
            ctx.fillStyle = '#ddd';
            for (let i = 0; i < 6; i++) {
                const tType = i % 2 === 0;
                ctx.beginPath();
                ctx.moveTo(x + 27 + i * 5 + shake, y + 25);
                ctx.lineTo(x + 29.5 + i * 5 + shake, y + (tType ? 30 : 22));
                ctx.lineTo(x + 32 + i * 5 + shake, y + 25);
                ctx.fill();
            }
            // Drool
            ctx.fillStyle = 'rgba(80, 180, 60, 0.7)';
            ctx.beginPath();
            ctx.moveTo(x + 35 + shake, y + 32);
            ctx.quadraticCurveTo(x + 36 + shake, y + 42 + Math.sin(b.frame * 0.1) * 3, x + 34 + shake, y + 48);
            ctx.lineTo(x + 38 + shake, y + 48);
            ctx.quadraticCurveTo(x + 39 + shake, y + 42, x + 37 + shake, y + 32);
            ctx.fill();

            // Arms (muscular)
            const armWave = Math.sin(b.frame * 0.08) * 8;
            ctx.fillStyle = '#1a3a1a';
            ctx.beginPath();
            ctx.ellipse(x - 5 + armWave + shake, y + 35 + breathe, 14, 8, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x - 15 + armWave + shake, y + 40 + breathe, 8, 6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + 85 - armWave + shake, y + 35 + breathe, 14, 8, 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(x + 95 - armWave + shake, y + 40 + breathe, 8, 6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Toxic particles
            if (Math.random() > 0.6) {
                addParticles(
                    b.x + 40 + (Math.random() - 0.5) * 60,
                    b.y + 30 + (Math.random() - 0.5) * 40,
                    '#44ff44', 1, 0.5, 20
                );
            }

            ctx.restore();

            // Health bar
            bossHealthBar.style.width = (b.hp / b.maxHp * 100) + '%';
        }

        // === DRAW APOCALYPTIC OBSTACLES ===
        function drawObstacles() {
            obstacles.forEach(o => {
                const x = o.x - camera.x, y = o.y - camera.y;
                if (x < -100 || x > canvas.width + 100 || y < -100 || y > canvas.height + 100) return;

                ctx.save();

                switch (o.type) {
                    case 'ruin': // Ruinas de edificio
                        ctx.fillStyle = '#2a2a2a';
                        ctx.fillRect(x, y, o.w, o.h);
                        // Grietas
                        ctx.strokeStyle = '#1a1a1a';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x + 10, y); ctx.lineTo(x + 20, y + o.h);
                        ctx.moveTo(x + o.w - 15, y); ctx.lineTo(x + o.w - 25, y + o.h / 2);
                        ctx.stroke();
                        // Ventanas rotas
                        ctx.fillStyle = '#0a0a0a';
                        ctx.fillRect(x + 8, y + 10, 12, 15);
                        ctx.fillRect(x + o.w - 22, y + 10, 12, 15);
                        // Borde
                        ctx.strokeStyle = '#1a1a1a';
                        ctx.strokeRect(x, y, o.w, o.h);
                        break;

                    case 'tree': // √Årbol quemado
                        // Tronco
                        ctx.fillStyle = '#1a1208';
                        ctx.fillRect(x + 10, y + 20, 10, 40);
                        // Ramas muertas
                        ctx.strokeStyle = '#2a1a0a';
                        ctx.lineWidth = 3;
                        ctx.beginPath();
                        ctx.moveTo(x + 15, y + 25); ctx.lineTo(x + 5, y + 10);
                        ctx.moveTo(x + 15, y + 25); ctx.lineTo(x + 25, y + 5);
                        ctx.moveTo(x + 15, y + 35); ctx.lineTo(x, y + 30);
                        ctx.moveTo(x + 15, y + 35); ctx.lineTo(x + 28, y + 28);
                        ctx.stroke();
                        break;

                    case 'tomb': // L√°pida
                        ctx.fillStyle = '#3a3a3a';
                        // Base
                        ctx.fillRect(x + 5, y + 35, 25, 10);
                        // L√°pida
                        ctx.beginPath();
                        ctx.moveTo(x + 7, y + 35);
                        ctx.lineTo(x + 7, y + 12);
                        ctx.quadraticCurveTo(x + 17, y, x + 28, y + 12);
                        ctx.lineTo(x + 28, y + 35);
                        ctx.fill();
                        // Cruz o RIP
                        ctx.fillStyle = '#1a1a1a';
                        ctx.font = '8px Courier';
                        ctx.fillText('RIP', x + 9, y + 25);
                        break;

                    case 'car': // Auto destruido
                        ctx.fillStyle = '#2a2a2a';
                        // Cuerpo
                        ctx.fillRect(x, y + 10, o.w, 20);
                        // Techo aplastado
                        ctx.fillRect(x + 15, y, 35, 12);
                        // Ruedas
                        ctx.fillStyle = '#1a1a1a';
                        ctx.beginPath();
                        ctx.arc(x + 12, y + 32, 8, 0, Math.PI * 2);
                        ctx.arc(x + o.w - 12, y + 32, 8, 0, Math.PI * 2);
                        ctx.fill();
                        // Fuego/humo
                        if (Math.random() > 0.7) {
                            ctx.fillStyle = 'rgba(100, 100, 100, 0.5)';
                            ctx.beginPath();
                            ctx.arc(x + 35, y - 5, 8 + Math.random() * 5, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;

                    case 'blood': // Charco de sangre (s√≥lido)
                        ctx.fillStyle = '#4a0a0a';
                        ctx.beginPath();
                        ctx.ellipse(x + o.w / 2, y + o.h / 2, o.w / 2, o.h / 3, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#3a0505';
                        ctx.beginPath();
                        ctx.ellipse(x + o.w / 2 + 5, y + o.h / 2 + 3, o.w / 4, o.h / 5, 0.3, 0, Math.PI * 2);
                        ctx.fill();
                        break;

                    case 'barrel': // Barril t√≥xico
                        ctx.fillStyle = '#3a3a00';
                        ctx.fillRect(x, y + 3, o.w, o.h - 6);
                        ctx.fillStyle = '#2a2a00';
                        ctx.fillRect(x, y, o.w, 5);
                        ctx.fillRect(x, y + o.h - 5, o.w, 5);
                        // S√≠mbolo t√≥xico
                        ctx.fillStyle = '#8a8a00';
                        ctx.beginPath();
                        ctx.arc(x + o.w / 2, y + o.h / 2, 6, 0, Math.PI * 2);
                        ctx.fill();
                        // Goteo
                        ctx.fillStyle = '#5a5a00';
                        ctx.fillRect(x + o.w - 3, y + o.h, 4, 8 + Math.random() * 5);
                        break;

                    case 'decor_blood': // Sangre decorativa (no bloquea)
                        ctx.fillStyle = 'rgba(80, 10, 10, 0.4)';
                        ctx.beginPath();
                        ctx.ellipse(x + o.w / 2, y + o.h / 2, o.w / 2, o.h / 3, Math.random(), 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }

                ctx.restore();
            });
        }

        // === DRAW STAR (IMPROVED - Gorilla Powerup) ===
        function drawStar(sx, sy, size, pulse) {
            const x = sx - camera.x, y = sy - camera.y;
            const glow = Math.sin(pulse * 0.1) * 0.5 + 0.5;
            const scale = 1 + glow * 0.3;
            const rot = pulse * 0.03;

            ctx.save();
            ctx.translate(x + size / 2, y + size / 2);
            ctx.rotate(rot);
            ctx.scale(scale, scale);

            // Outer glow ring
            ctx.shadowColor = '#ffdd00';
            ctx.shadowBlur = 15 + glow * 15;
            ctx.strokeStyle = `rgba(255, 220, 0, ${0.3 + glow * 0.4})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, size * 0.7, 0, Math.PI * 2);
            ctx.stroke();

            // Star shape (5-pointed)
            ctx.fillStyle = '#ffcc00';
            ctx.strokeStyle = '#aa8800';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let i = 0; i < 10; i++) {
                const angle = (Math.PI * 2 / 10) * i - Math.PI / 2;
                const r = i % 2 === 0 ? size * 0.5 : size * 0.22;
                const px = Math.cos(angle) * r;
                const py = Math.sin(angle) * r;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Inner highlight
            ctx.fillStyle = '#ffee88';
            ctx.beginPath();
            ctx.arc(0, -2, size * 0.12, 0, Math.PI * 2);
            ctx.fill();

            // Gorilla emoji in center
            ctx.shadowBlur = 0;
            ctx.font = `${size * 0.4}px serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('ü¶ç', 0, 1);

            ctx.restore();

            // Sparkle particles
            if (Math.random() > 0.7) {
                addParticles(sx + size / 2, sy + size / 2, '#ffdd00', 1, 0.8, 15);
            }
        }

        // === RESIDENT EVIL STYLE FLOOR (IMPROVED) ===
        function drawFloor() {
            const tileSize = 60;
            const startX = Math.floor(camera.x / tileSize) * tileSize;
            const startY = Math.floor(camera.y / tileSize) * tileSize;

            for (let x = startX - tileSize; x < camera.x + canvas.width + tileSize; x += tileSize) {
                for (let y = startY - tileSize; y < camera.y + canvas.height + tileSize; y += tileSize) {
                    const screenX = x - camera.x;
                    const screenY = y - camera.y;

                    // Checkered pattern with subtle color variation
                    const isDark = ((x / tileSize + y / tileSize) % 2) === 0;
                    const seed = Math.abs((x * 7 + y * 13)) % 100;
                    const tint = seed % 8;
                    ctx.fillStyle = isDark ? `rgb(${28 + tint}, ${28 + tint}, ${28 + tint})` : `rgb(${35 + tint}, ${35 + tint}, ${35 + tint})`;
                    ctx.fillRect(screenX, screenY, tileSize, tileSize);

                    // Grout lines
                    ctx.strokeStyle = '#0a0a0a';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(screenX, screenY, tileSize, tileSize);

                    // Inner tile highlight (subtle 3D)
                    ctx.strokeStyle = isDark ? 'rgba(255,255,255,0.03)' : 'rgba(255,255,255,0.05)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(screenX + 2, screenY + tileSize - 2);
                    ctx.lineTo(screenX + 2, screenY + 2);
                    ctx.lineTo(screenX + tileSize - 2, screenY + 2);
                    ctx.stroke();

                    // Cracks (seeded by position)
                    if (seed < 15) {
                        ctx.strokeStyle = '#0f0f0f';
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(screenX + 10, screenY + 20);
                        ctx.lineTo(screenX + 30, screenY + 35);
                        ctx.lineTo(screenX + 45, screenY + 50);
                        ctx.stroke();
                    }
                    if (seed > 20 && seed < 28) {
                        ctx.strokeStyle = '#111';
                        ctx.lineWidth = 0.8;
                        ctx.beginPath();
                        ctx.moveTo(screenX + 50, screenY + 5);
                        ctx.lineTo(screenX + 35, screenY + 30);
                        ctx.lineTo(screenX + 20, screenY + 55);
                        ctx.stroke();
                    }

                    // Blood stains
                    if (seed > 85 && seed < 95) {
                        ctx.fillStyle = 'rgba(60, 10, 10, 0.5)';
                        ctx.beginPath();
                        ctx.ellipse(screenX + 30, screenY + 30, 15, 10, seed * 0.1, 0, Math.PI * 2);
                        ctx.fill();
                        // Blood splatter detail
                        ctx.fillStyle = 'rgba(80, 5, 5, 0.3)';
                        ctx.beginPath();
                        ctx.arc(screenX + 18, screenY + 22, 5, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    // Dirt/debris marks
                    if (seed > 40 && seed < 48) {
                        ctx.fillStyle = 'rgba(40, 35, 25, 0.3)';
                        ctx.beginPath();
                        ctx.ellipse(screenX + 20 + seed % 20, screenY + 15 + seed % 15, 8, 5, seed * 0.05, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            // Dynamic lighting around player
            const plx = player.x - camera.x + player.w / 2;
            const ply = player.y - camera.y + player.h / 2;
            const lightGrad = ctx.createRadialGradient(plx, ply, 30, plx, ply, 250);
            lightGrad.addColorStop(0, 'rgba(255, 200, 100, 0.06)');
            lightGrad.addColorStop(0.5, 'rgba(0,0,0,0)');
            lightGrad.addColorStop(1, 'rgba(0,0,0,0.35)');
            ctx.fillStyle = lightGrad;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // === SCANLINES + VIGNETTE ===
        function drawScanlines() {
            ctx.fillStyle = 'rgba(0,0,0,0.05)';
            for (let y = 0; y < canvas.height; y += 3) {
                ctx.fillRect(0, y, canvas.width, 1);
            }
            // Vignette
            const vig = ctx.createRadialGradient(
                canvas.width / 2, canvas.height / 2, canvas.width * 0.3,
                canvas.width / 2, canvas.height / 2, canvas.width * 0.75
            );
            vig.addColorStop(0, 'rgba(0,0,0,0)');
            vig.addColorStop(1, 'rgba(0,0,0,0.4)');
            ctx.fillStyle = vig;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Floating text
        function addFloat(x, y, text) { gs.floats.push({ x, y, text, life: 50, vy: -2 }); }

        function drawFloats() {
            gs.floats = gs.floats.filter(f => {
                f.y += f.vy;
                f.life--;
                if (f.life > 0) {
                    const x = f.x - camera.x, y = f.y - camera.y;
                    ctx.save();
                    ctx.font = 'bold 13px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillStyle = `rgba(255,255,255,${f.life / 50})`;
                    ctx.strokeStyle = `rgba(0,0,0,${f.life / 50})`;
                    ctx.lineWidth = 2;
                    ctx.strokeText(f.text, x, y);
                    ctx.fillText(f.text, x, y);
                    ctx.restore();
                    return true;
                }
                return false;
            });
        }

        // Gorilla speech
        function showSpeech(text) {
            gorillaSpeech.innerText = text;
            gorillaSpeech.style.display = 'block';
            gs.goriSpeechTimer = 80;
        }

        function updateSpeech() {
            if (gs.goriSpeechTimer > 0) {
                gs.goriSpeechTimer--;
                const rect = container.getBoundingClientRect();
                const sx = (gorilla.x - camera.x) / canvas.width * rect.width + 10;
                const sy = (gorilla.y - camera.y - 60) / canvas.height * rect.height;
                gorillaSpeech.style.left = sx + 'px';
                gorillaSpeech.style.top = Math.max(0, sy) + 'px';
                if (gs.goriSpeechTimer <= 0) gorillaSpeech.style.display = 'none';
            }
        }

        // Gorilla AI
        function updateGorilla() {
            if (!gs.goriActive) return;

            gorilla.walk++;
            if (gorilla.punch > 0) gorilla.punch--;

            // Activate satanic mode if boss exists
            gs.satanic = boss !== null;

            // Find target (prefer boss)
            let target = null;
            let minDist = Infinity;

            if (boss) {
                target = boss;
                minDist = Math.hypot(boss.x - gorilla.x, boss.y - gorilla.y);
            } else {
                zombies.forEach(z => {
                    const d = Math.hypot(z.x - gorilla.x, z.y - gorilla.y);
                    if (d < minDist) { minDist = d; target = z; }
                });
            }

            if (target) {
                const dx = target.x - gorilla.x;
                const dy = target.y - gorilla.y;
                const angle = Math.atan2(dy, dx);
                const spd = minDist < 80 ? gorilla.speed * 1.4 : gorilla.speed;

                gorilla.x += Math.cos(angle) * spd;
                gorilla.y += Math.sin(angle) * spd;

                // Collision
                if (collide(gorilla, target)) {
                    gorilla.punch = 18;

                    if (target === boss) {
                        boss.hp -= 3;
                        boss.hit = 10;
                        addFloat(boss.x + 40, boss.y, '-3');
                        showSpeech(gs.satanic ? "MUERE DEMONIO CULIAO üëπüî•" : GORILLA_PHRASES[Math.floor(Math.random() * GORILLA_PHRASES.length)]);

                        if (boss.hp <= 0) {
                            gs.score += 50;
                            addFloat(boss.x + 40, boss.y, '+50 BOSS!');
                            boss = null;
                            bossHealthEl.style.display = 'none';
                            bossLabel.style.display = 'none';
                            gs.satanic = false;
                        }
                    } else {
                        zombies = zombies.filter(z => z !== target);
                        gs.score += 5;
                        gs.kills++;
                        addFloat(target.x, target.y, '+5');
                        showSpeech(GORILLA_PHRASES[Math.floor(Math.random() * GORILLA_PHRASES.length)]);
                    }
                    updateUI();
                    checkRoom();
                }
            } else {
                // Patrol near player
                gorilla.x += (player.x - gorilla.x) * 0.02;
                gorilla.y += (player.y - 50 - gorilla.y) * 0.02;
            }

            gs.goriTimer--;
            if (gs.goriTimer <= 0) {
                gs.goriActive = false;
                gs.satanic = false;
                gorilla.x = -200;
                gorillaSpeech.style.display = 'none';
                updateUI();
            }
        }

        // Spawners
        function spawnZombie() {
            if (gs.over || gs.paused || gs.won) return;

            const dirs = [[0, -30], [0, WORLD.h + 30], [-30, WORLD.h / 2], [WORLD.w + 30, WORLD.h / 2]];
            const [bx, by] = dirs[Math.floor(Math.random() * 4)];
            const x = bx === 0 || bx === WORLD.w + 30 ? bx : 50 + Math.random() * (WORLD.w - 100);
            const y = by === WORLD.h / 2 ? 50 + Math.random() * (WORLD.h - 100) : by;

            zombies.push({ x, y, w: 26, h: 28, speed: 0.4 + Math.random() * 0.3 + gs.room * 0.03, frame: Math.random() * 100 });
        }

        function spawnItem() {
            if (gs.over || gs.paused || gs.won) return;
            items.push({ x: 100 + Math.random() * (WORLD.w - 200), y: 100 + Math.random() * (WORLD.h - 200), w: 24, h: 24 });
        }

        // Fire weapon
        let lastFire = 0;
        function fire() {
            if (gs.over || gs.paused || gs.won) return;

            const now = Date.now();
            const w = WEAPONS[gs.weapon];
            if (now - lastFire < w.fireRate) return;
            lastFire = now;

            // Auto-aim: nudge aim toward nearest zombie
            let aimAngle = player.aim;
            let nearDist = 300;
            const allTargets = boss ? [...zombies, boss] : zombies;
            for (const z of allTargets) {
                const dx = (z.x + z.w / 2) - (player.x + player.w / 2);
                const dy = (z.y + z.h / 2) - (player.y + player.h / 2);
                const d = Math.hypot(dx, dy);
                if (d < nearDist) {
                    const zAngle = Math.atan2(dy, dx);
                    // Only assist if zombie is roughly in aim direction (within 45 deg)
                    let diff = zAngle - player.aim;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    if (Math.abs(diff) < 0.8) {
                        aimAngle = player.aim + diff * 0.4; // 40% correction
                        nearDist = d;
                    }
                }
            }

            for (let i = 0; i < w.pellets; i++) {
                const spread = (Math.random() - 0.5) * w.spread * 2;
                const angle = aimAngle + spread;
                const speed = w.isFlame ? 5 : 9;

                bullets.push({
                    x: player.x + player.w / 2 - 4,
                    y: player.y + player.h / 2 - 4,
                    w: w.isFlame ? 14 : 10,
                    h: w.isFlame ? 14 : 10,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    damage: w.damage,
                    color: w.color,
                    isFlame: w.isFlame,
                    life: w.isFlame ? 40 : 999
                });
            }
        }

        function collide(a, b) {
            return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
        }

        function collideObs(e) {
            for (const o of obstacles) {
                if (o.noCollide) continue; // Decorative obstacles don't block
                if (collide(e, o)) return true;
            }
            return false;
        }

        function showGameOver() {
            gs.over = true;
            checkpoint = gs.room; // Guardar checkpoint en el nivel actual
            gameOverMessage.innerText = GAME_OVER_MSG[Math.floor(Math.random() * GAME_OVER_MSG.length)];
            finalScore.innerText = `Score: ${gs.score} | Habitaci√≥n: ${gs.room}/${MAX_ROOMS} (Contin√∫as aqu√≠)`;
            gameOverScreen.style.display = 'flex';
        }

        function checkRoom() {
            const needBossKill = (gs.room === 4 || gs.room === 7) && boss !== null;
            if (gs.kills >= gs.toKill && !needBossKill) {
                if (gs.room >= MAX_ROOMS) showVictory();
                else nextRoom();
            }
        }

        function nextRoom() {
            gs.room++;
            gs.kills = 0;
            gs.toKill = 12 + gs.room * 2;
            player.x = WORLD.w / 2 - 16;
            player.y = WORLD.h / 2 - 16;
            zombies = [];
            genObstacles();
            updateUI();
            showIntro();
        }

        // Main loop
        function update() {
            if (gs.paused || gs.over || gs.won) { requestAnimationFrame(update); return; }

            gs.pulse++;
            player.frame++;

            // Camera follows player (expandable map)
            const targetCamX = player.x - canvas.width / 2 + player.w / 2;
            const targetCamY = player.y - canvas.height / 2 + player.h / 2;
            camera.x += (targetCamX - camera.x) * 0.1;
            camera.y += (targetCamY - camera.y) * 0.1;

            // Keep camera in bounds
            camera.x = Math.max(0, Math.min(WORLD.w - canvas.width, camera.x));
            camera.y = Math.max(0, Math.min(WORLD.h - canvas.height, camera.y));

            // Background - Dark apocalyptic
            ctx.fillStyle = C.BG;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw RE-style floor tiles
            drawFloor();

            // World border (rusty metal)
            ctx.strokeStyle = '#3a2a1a';
            ctx.lineWidth = 8;
            ctx.strokeRect(-camera.x - 2, -camera.y - 2, WORLD.w + 4, WORLD.h + 4);
            ctx.strokeStyle = '#2a1a0a';
            ctx.lineWidth = 4;
            ctx.strokeRect(-camera.x, -camera.y, WORLD.w, WORLD.h);

            drawObstacles();

            // Player movement (no border collision - expandable map)
            const nx = player.x + player.dx;
            const ny = player.y + player.dy;

            if (nx >= 0 && nx <= WORLD.w - player.w) player.x = nx;
            if (ny >= 0 && ny <= WORLD.h - player.h) player.y = ny;

            if (collideObs(player)) {
                player.x -= player.dx;
                player.y -= player.dy;
            }

            // Bullets
            bullets = bullets.filter(b => {
                b.x += b.vx;
                b.y += b.vy;
                if (b.life !== 999) b.life--;

                const bx = b.x - camera.x, by = b.y - camera.y;

                if (b.isFlame) {
                    // Nicer flame with glow
                    ctx.save();
                    ctx.shadowColor = '#ff6600';
                    ctx.shadowBlur = 8;
                    ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 0, ${0.6 + Math.random() * 0.4})`;
                    ctx.beginPath();
                    ctx.arc(bx, by, 5 + Math.random() * 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = `rgba(255, ${200 + Math.random() * 55}, 50, 0.8)`;
                    ctx.beginPath();
                    ctx.arc(bx, by, 2 + Math.random() * 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    // Smoke trail
                    if (Math.random() > 0.5) addParticles(b.x, b.y, 'rgba(80,80,80,0.4)', 1, 0.3, 12);
                } else {
                    // Bullet with glow trail
                    ctx.save();
                    ctx.shadowColor = b.color;
                    ctx.shadowBlur = 6;
                    ctx.fillStyle = b.color;
                    ctx.beginPath();
                    ctx.arc(bx + 3, by + 3, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(bx + 3, by + 3, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

                if (collideObs(b)) return false;
                if (b.life <= 0) return false;

                // Hit zombies
                for (let i = zombies.length - 1; i >= 0; i--) {
                    if (collide(b, zombies[i])) {
                        addFloat(zombies[i].x, zombies[i].y, '+1');
                        addParticles(zombies[i].x + 8, zombies[i].y + 10, '#44aa44', 8, 2, 25);
                        addParticles(zombies[i].x + 8, zombies[i].y + 10, '#882222', 5, 1.5, 20);
                        zombies.splice(i, 1);
                        gs.score++;
                        gs.kills++;
                        updateUI();
                        checkRoom();
                        return false;
                    }
                }

                // Hit boss
                if (boss && collide(b, boss)) {
                    boss.hp -= b.damage;
                    boss.hit = 8;

                    if (boss.hp <= 0) {
                        gs.score += 50;
                        addFloat(boss.x + 40, boss.y, '+50 BOSS!');
                        boss = null;
                        bossHealthEl.style.display = 'none';
                        bossLabel.style.display = 'none';
                        gs.satanic = false;
                        updateUI();
                        checkRoom();
                    }
                    return false;
                }

                return b.x > -50 && b.x < WORLD.w + 50 && b.y > -50 && b.y < WORLD.h + 50;
            });

            // Zombies
            zombies.forEach(z => {
                z.frame++;
                const dx = player.x - z.x, dy = player.y - z.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 0) {
                    const nzx = z.x + (dx / dist) * z.speed;
                    const nzy = z.y + (dy / dist) * z.speed;
                    const test = { x: nzx, y: nzy, w: z.w, h: z.h };
                    if (!collideObs(test)) { z.x = nzx; z.y = nzy; }
                    else { z.x += (dy / dist) * z.speed * 0.5; z.y += (-dx / dist) * z.speed * 0.5; }
                }
                drawZombie(z.x, z.y, z.frame);
                if (collide(z, player)) showGameOver();
            });

            // Boss
            if (boss) {
                if (boss.hit > 0) boss.hit--;
                const dx = player.x - boss.x - 20;
                const dy = player.y - boss.y - 20;
                const dist = Math.hypot(dx, dy);
                if (dist > 60) {
                    boss.x += (dx / dist) * boss.speed;
                    boss.y += (dy / dist) * boss.speed;
                }
                drawBoss(boss);
                if (collide(boss, player)) showGameOver();
            }

            // Items
            items = items.filter(item => {
                drawStar(item.x, item.y, item.w, gs.pulse);
                if (collide(item, player)) {
                    gs.goriActive = true;
                    gs.goriTimer = 500;
                    gorilla.x = player.x - 30;
                    gorilla.y = player.y - 40;
                    showSpeech("LLEG√ì EL CHORO M√ÅS CHORO ü¶çüí™ WUOM");
                    updateUI();
                    return false;
                }
                return true;
            });

            updateGorilla();
            updateSpeech();

            drawHelloKitty(player.x, player.y, player.frame, player.aim - Math.PI / 2);

            if (gs.goriActive) drawGorilla(gorilla.x, gorilla.y, gorilla.punch, gorilla.walk);

            drawFloats();
            updateParticles();
            drawScanlines();

            requestAnimationFrame(update);
        }

        // Controls
        const jc = $('joystickContainer');
        jc.ontouchstart = e => {
            e.preventDefault();
            const r = jc.getBoundingClientRect();
            joystick.active = true;
            joystick.baseX = r.left + r.width / 2;
            joystick.baseY = r.top + r.height / 2;
        };

        jc.ontouchmove = e => {
            e.preventDefault();
            if (!joystick.active) return;
            const t = e.touches[0];
            let dx = t.clientX - joystick.baseX;
            let dy = t.clientY - joystick.baseY;
            const dist = Math.hypot(dx, dy);
            if (dist > joystick.maxDist) { dx = dx / dist * joystick.maxDist; dy = dy / dist * joystick.maxDist; }
            joystickStick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            player.dx = (dx / joystick.maxDist) * player.speed;
            player.dy = (dy / joystick.maxDist) * player.speed;
            if (dist > 5) player.aim = Math.atan2(dy, dx);
        };

        function resetJoy() {
            joystick.active = false;
            joystickStick.style.transform = 'translate(-50%, -50%)';
            player.dx = 0;
            player.dy = 0;
        }
        jc.ontouchend = resetJoy;
        jc.ontouchcancel = resetJoy;

        let fireInt = null;
        const fb = $('fireButton');
        fb.ontouchstart = e => { e.preventDefault(); fire(); fireInt = setInterval(fire, WEAPONS[gs.weapon].fireRate); };
        fb.ontouchend = () => { if (fireInt) { clearInterval(fireInt); fireInt = null; } };
        fb.ontouchcancel = () => { if (fireInt) { clearInterval(fireInt); fireInt = null; } };

        // Keyboard
        const keys = {};
        document.onkeydown = e => { keys[e.key] = true; if (e.key === ' ') { e.preventDefault(); fire(); } updateKeys(); };
        document.onkeyup = e => { keys[e.key] = false; updateKeys(); };

        function updateKeys() {
            player.dx = 0; player.dy = 0;
            if (keys.ArrowLeft || keys.a) { player.dx = -player.speed; player.aim = Math.PI; }
            if (keys.ArrowRight || keys.d) { player.dx = player.speed; player.aim = 0; }
            if (keys.ArrowUp || keys.w) { player.dy = -player.speed; player.aim = -Math.PI / 2; }
            if (keys.ArrowDown || keys.s) { player.dy = player.speed; player.aim = Math.PI / 2; }
            if (player.dx && player.dy) player.aim = Math.atan2(player.dy, player.dx);
            if (keys.q) { gs.weapon = (gs.weapon + 1) % WEAPONS.length; keys.q = false; updateUI(); }
        }

        // Spawners - M√ÅS ZOMBIS!
        setInterval(spawnZombie, 700); // Era 1400, ahora el doble de zombis
        setInterval(spawnItem, 14000);
        setTimeout(spawnItem, 6000);

        init();
        requestAnimationFrame(update);
        console.log('%cüéÄ Protocolo Goril√≥n v2.0', 'font-size: 20px; color: #ff69b4; background: #0f380f; padding: 10px;');


    </script>
</body>

</html>